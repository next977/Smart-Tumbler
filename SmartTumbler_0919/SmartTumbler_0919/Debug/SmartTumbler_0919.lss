
SmartTumbler_0919.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         0000002a  00800100  0000109c  00001130  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         0000109c  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000206  0080012a  0080012a  0000115a  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  0000115a  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 0000003c  00000000  00000000  0000118c  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 000000d0  00000000  00000000  000011c8  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00001d55  00000000  00000000  00001298  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00000510  00000000  00000000  00002fed  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00000dec  00000000  00000000  000034fd  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  000002e4  00000000  00000000  000042ec  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    0000041b  00000000  00000000  000045d0  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00001842  00000000  00000000  000049eb  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000130  00000000  00000000  0000622d  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	45 c0       	rjmp	.+138    	; 0x8c <__ctors_end>
       2:	00 00       	nop
       4:	60 c0       	rjmp	.+192    	; 0xc6 <__bad_interrupt>
       6:	00 00       	nop
       8:	5e c0       	rjmp	.+188    	; 0xc6 <__bad_interrupt>
       a:	00 00       	nop
       c:	5c c0       	rjmp	.+184    	; 0xc6 <__bad_interrupt>
       e:	00 00       	nop
      10:	5a c0       	rjmp	.+180    	; 0xc6 <__bad_interrupt>
      12:	00 00       	nop
      14:	58 c0       	rjmp	.+176    	; 0xc6 <__bad_interrupt>
      16:	00 00       	nop
      18:	56 c0       	rjmp	.+172    	; 0xc6 <__bad_interrupt>
      1a:	00 00       	nop
      1c:	54 c0       	rjmp	.+168    	; 0xc6 <__bad_interrupt>
      1e:	00 00       	nop
      20:	52 c0       	rjmp	.+164    	; 0xc6 <__bad_interrupt>
      22:	00 00       	nop
      24:	50 c0       	rjmp	.+160    	; 0xc6 <__bad_interrupt>
      26:	00 00       	nop
      28:	4e c0       	rjmp	.+156    	; 0xc6 <__bad_interrupt>
      2a:	00 00       	nop
      2c:	4c c0       	rjmp	.+152    	; 0xc6 <__bad_interrupt>
      2e:	00 00       	nop
      30:	4a c0       	rjmp	.+148    	; 0xc6 <__bad_interrupt>
      32:	00 00       	nop
      34:	48 c0       	rjmp	.+144    	; 0xc6 <__bad_interrupt>
      36:	00 00       	nop
      38:	46 c0       	rjmp	.+140    	; 0xc6 <__bad_interrupt>
      3a:	00 00       	nop
      3c:	44 c0       	rjmp	.+136    	; 0xc6 <__bad_interrupt>
      3e:	00 00       	nop
      40:	4f c0       	rjmp	.+158    	; 0xe0 <__vector_16>
      42:	00 00       	nop
      44:	40 c0       	rjmp	.+128    	; 0xc6 <__bad_interrupt>
      46:	00 00       	nop
      48:	3e c0       	rjmp	.+124    	; 0xc6 <__bad_interrupt>
      4a:	00 00       	nop
      4c:	3c c0       	rjmp	.+120    	; 0xc6 <__bad_interrupt>
      4e:	00 00       	nop
      50:	3a c0       	rjmp	.+116    	; 0xc6 <__bad_interrupt>
      52:	00 00       	nop
      54:	38 c0       	rjmp	.+112    	; 0xc6 <__bad_interrupt>
      56:	00 00       	nop
      58:	36 c0       	rjmp	.+108    	; 0xc6 <__bad_interrupt>
      5a:	00 00       	nop
      5c:	34 c0       	rjmp	.+104    	; 0xc6 <__bad_interrupt>
      5e:	00 00       	nop
      60:	32 c0       	rjmp	.+100    	; 0xc6 <__bad_interrupt>
      62:	00 00       	nop
      64:	30 c0       	rjmp	.+96     	; 0xc6 <__bad_interrupt>
      66:	00 00       	nop
      68:	2e c0       	rjmp	.+92     	; 0xc6 <__bad_interrupt>
      6a:	00 00       	nop
      6c:	2c c0       	rjmp	.+88     	; 0xc6 <__bad_interrupt>
      6e:	00 00       	nop
      70:	2a c0       	rjmp	.+84     	; 0xc6 <__bad_interrupt>
      72:	00 00       	nop
      74:	28 c0       	rjmp	.+80     	; 0xc6 <__bad_interrupt>
      76:	00 00       	nop
      78:	59 c0       	rjmp	.+178    	; 0x12c <__vector_30>
      7a:	00 00       	nop
      7c:	24 c0       	rjmp	.+72     	; 0xc6 <__bad_interrupt>
      7e:	00 00       	nop
      80:	22 c0       	rjmp	.+68     	; 0xc6 <__bad_interrupt>
      82:	00 00       	nop
      84:	20 c0       	rjmp	.+64     	; 0xc6 <__bad_interrupt>
      86:	00 00       	nop
      88:	1e c0       	rjmp	.+60     	; 0xc6 <__bad_interrupt>
	...

0000008c <__ctors_end>:
      8c:	11 24       	eor	r1, r1
      8e:	1f be       	out	0x3f, r1	; 63
      90:	cf ef       	ldi	r28, 0xFF	; 255
      92:	d0 e1       	ldi	r29, 0x10	; 16
      94:	de bf       	out	0x3e, r29	; 62
      96:	cd bf       	out	0x3d, r28	; 61

00000098 <__do_copy_data>:
      98:	11 e0       	ldi	r17, 0x01	; 1
      9a:	a0 e0       	ldi	r26, 0x00	; 0
      9c:	b1 e0       	ldi	r27, 0x01	; 1
      9e:	ec e9       	ldi	r30, 0x9C	; 156
      a0:	f0 e1       	ldi	r31, 0x10	; 16
      a2:	00 e0       	ldi	r16, 0x00	; 0
      a4:	0b bf       	out	0x3b, r16	; 59
      a6:	02 c0       	rjmp	.+4      	; 0xac <__do_copy_data+0x14>
      a8:	07 90       	elpm	r0, Z+
      aa:	0d 92       	st	X+, r0
      ac:	aa 32       	cpi	r26, 0x2A	; 42
      ae:	b1 07       	cpc	r27, r17
      b0:	d9 f7       	brne	.-10     	; 0xa8 <__do_copy_data+0x10>

000000b2 <__do_clear_bss>:
      b2:	23 e0       	ldi	r18, 0x03	; 3
      b4:	aa e2       	ldi	r26, 0x2A	; 42
      b6:	b1 e0       	ldi	r27, 0x01	; 1
      b8:	01 c0       	rjmp	.+2      	; 0xbc <.do_clear_bss_start>

000000ba <.do_clear_bss_loop>:
      ba:	1d 92       	st	X+, r1

000000bc <.do_clear_bss_start>:
      bc:	a0 33       	cpi	r26, 0x30	; 48
      be:	b2 07       	cpc	r27, r18
      c0:	e1 f7       	brne	.-8      	; 0xba <.do_clear_bss_loop>
      c2:	ce d1       	rcall	.+924    	; 0x460 <main>
      c4:	e9 c7       	rjmp	.+4050   	; 0x1098 <_exit>

000000c6 <__bad_interrupt>:
      c6:	9c cf       	rjmp	.-200    	; 0x0 <__vectors>

000000c8 <TIMER_Init>:
void TIMER_Init (void)
{
	// Timer/Count0 사용
	// 타이머를 이용해서 1초를 만들어 주는것이 이프로그램의 목적임!
	// 동작모드와 클럭소스 및 프리스케일러 결정
	TCCR0	=	0x07;  // 0000 0111일때 111은 CSn2, CSn1, CSn0 의 값들이 111로 받아 본책 228페이지의 1024의 분주값.
      c8:	87 e0       	ldi	r24, 0x07	; 7
      ca:	83 bf       	out	0x33, r24	; 51

	/* 0.01s에 오버플로우 발생, 1/(14745600Hz/1024)ⅹ45 = 0.03s  14745600hz는 cpu의 주파수 인데 이것은 14745600주기이다. 근데 이것의 초를 구하려면 1/14745600이고 
	X144를 해줘야 0.01초 를 만들어 줄 수 있다.*/ 
	// 오버플로우까지 카운트를 144로 설정
	TCNT0	=	0xff - 45; /*0xff이면 1111 1111이므로 255까지 카운터를 할 수 있는데, 여기서 256이면 오버풀러 이므로 256을 쓸수가 없어 144를 빼주어 111부터 144개를 카운터 하여
      cc:	82 ed       	ldi	r24, 0xD2	; 210
      ce:	82 bf       	out	0x32, r24	; 50
	                          111+144 즉 255를 만들어 주고 다음번 째 카운터에 256을 만들어줘 오버플로우 발생시켜 인터럽트가 걸리게끔 해주기위함임!.*/
	TIMSK |=	1 << TOIE0;	 /* Overflow Interupt Enable  트리거가 완료되어 인터럽트의 요청이 되면 이 값의 (1의 값)을 주어 인터럽트를 허용해주는 레지스터.
      d0:	87 b7       	in	r24, 0x37	; 55
      d2:	81 60       	ori	r24, 0x01	; 1
      d4:	87 bf       	out	0x37, r24	; 55
															TOIE0이라는 것은 TIMSK의 0비트에 해당이 되는 것인데, TOIE0의값은 초기값이 0이고 1<<TOIEO은 
															0만큼 왼쪽으로 1칸 옴기라는 뜻이므로 결국 아무런 영향을 주지 못한다.
															기본적으로 1<<TOIE0의 연산자를 먼저 수행하고 TIMSK or 1을 수행하므로 TIMSK or 1은 TIMSK도 초기값
															0000 0000 이고 0000 0001이므로 or은 0000 0001로 나타나 진다. 즉 TIMSK는 0000 0001이되며 마지막 0의
															비트값이 1로 작동 된다는 소리이다. (인터럽트의 마스크와 비슷한 맥락)*/
	TIFR |=	1 << TOV0;	/* set Overflow Interupt Flag  // 이 값의 허용치가 되어 인터럽트가 걸리면 깃발을 들어줘 (1의 값) 인터럽트를 허용해주는 레지스터
      d6:	86 b7       	in	r24, 0x36	; 54
      d8:	81 60       	ori	r24, 0x01	; 1
      da:	86 bf       	out	0x36, r24	; 54
	                        TIFR도 TOV0이 0비트이기 때문에 TIMSK와 똑같은 역할을 함. 즉 0의 비트가 1로 작동이 된다는 소리 
	                    근데 그러면 구지 TOV0과 연산자를 왜 써주냐면 TIFR의 0의 비트가 무슨 값인지 모르기 때문에 사용자가 책을 펴볼수박에없는데 TOV0와 <<1로 TOV0의
						값을 나타내주어 사용자가 더 편하게 프로그램을 짤 수 있도록 하는 문장. */
	sei();
      dc:	78 94       	sei
      de:	08 95       	ret

000000e0 <__vector_16>:
}
ISR (TIMER0_OVF_vect)	/* Timer0 Overflow0 ISP		0.003초 마다 인터럽트에 걸리게 하여 카운터를 세고, 그 카운터가 100이 되었을때,													즉 0.3초 마다 ADCL,ADCH의 데이터를 읽어 조도의 데이터를 LED나 FND로 표현 */
{
      e0:	1f 92       	push	r1
      e2:	0f 92       	push	r0
      e4:	0f b6       	in	r0, 0x3f	; 63
      e6:	0f 92       	push	r0
      e8:	11 24       	eor	r1, r1
      ea:	2f 93       	push	r18
      ec:	8f 93       	push	r24
      ee:	9f 93       	push	r25
	//cli(); // 인터럽트 종료.
	
	unsigned char ucLowValue	=	0; //ADC 변환 결과 값에서 ADCL 값을 저장할 변수를 선언
	unsigned char ucHighValue	=	0;	//ADC 변환 결과 값에서 ADCH 값을 저장할 변수를 선언.
	
	TCNT0	=	0xff - 45;		// 0.003s 0.003s를 맞춰주기 위해 -45를 함.
      f0:	82 ed       	ldi	r24, 0xD2	; 210
      f2:	82 bf       	out	0x32, r24	; 50
	g_ucOverflowCnt++;
      f4:	80 91 88 01 	lds	r24, 0x0188	; 0x800188 <g_ucOverflowCnt>
      f8:	8f 5f       	subi	r24, 0xFF	; 255
	
	if (g_ucOverflowCnt == 100)		/* 0.003s * 100 = 0.3s 0.3초 마다 ADCL과 ADCH를 변수에 받아들여 센서 값을 읽어옴
      fa:	84 36       	cpi	r24, 0x64	; 100
      fc:	19 f0       	breq	.+6      	; 0x104 <__vector_16+0x24>
	
	unsigned char ucLowValue	=	0; //ADC 변환 결과 값에서 ADCL 값을 저장할 변수를 선언
	unsigned char ucHighValue	=	0;	//ADC 변환 결과 값에서 ADCH 값을 저장할 변수를 선언.
	
	TCNT0	=	0xff - 45;		// 0.003s 0.003s를 맞춰주기 위해 -45를 함.
	g_ucOverflowCnt++;
      fe:	80 93 88 01 	sts	0x0188, r24	; 0x800188 <g_ucOverflowCnt>
     102:	0c c0       	rjmp	.+24     	; 0x11c <__vector_16+0x3c>
	
	if (g_ucOverflowCnt == 100)		/* 0.003s * 100 = 0.3s 0.3초 마다 ADCL과 ADCH를 변수에 받아들여 센서 값을 읽어옴
									 0.3초마다 ADC변환을 하는것*/
	{
		g_ucOverflowCnt	=	0;
     104:	10 92 88 01 	sts	0x0188, r1	; 0x800188 <g_ucOverflowCnt>
		// ADC 변환이 끝날떄 까지 대기
		while ( (ADCSRA & 0x10)==0x00);	/* 0x10과 ADCSRA과 and 한 값이 0x00이면 while문 실행, 즉 무조건 0x00으로 
     108:	34 9b       	sbis	0x06, 4	; 6
     10a:	fe cf       	rjmp	.-4      	; 0x108 <__vector_16+0x28>
										while문을 실행하고 아무런 실행문의 문장이 없으니 그대로 멈추어 있음.
									   근데 ; 이 있으니  ; 까지 수행.while문 께속 돌다가 ADC가 완료 되어서 ADCSRA ADIF비트가 
									   1로 셋되면 while문을 나옴. 
										 */
		
		ucLowValue	=	ADCL; //ADCL 0~7번까지의 비트의 결과값을 (데이터를) 저장한다.
     10c:	84 b1       	in	r24, 0x04	; 4
		ucHighValue	=	ADCH ;	//ADCH 즉 8비트 이상의 결과값을 (데이터를) 저장한다. 
     10e:	25 b1       	in	r18, 0x05	; 5
		
		/* 64를 14745600의 hz를 64로 분주하여 샘플링한 값을 표로 나타내고 2.56v로 분배능을 하여 총 조도센서에서 읽어지는 아날로그
		값을 예를 들면 256이라고 하면 255까지는 8비트 1111 1111으로 표현할수 있기 때문에 ADCL로 데이터를 받아들여 저장하고,
		나머지 255에서 저장하고 남은 1의 값을 ADCH에서 데이터를 받아들여 저장한다. */
		
		g_unAdcValue	=	(ucHighValue << 8) | ucLowValue ; /* 138페이지 원래 ADLAR을 0으로 맞춰 줬기 때문에 기본적으로 상위비트는 8,9번
     110:	90 e0       	ldi	r25, 0x00	; 0
     112:	92 2b       	or	r25, r18
     114:	90 93 8a 01 	sts	0x018A, r25	; 0x80018a <g_unAdcValue+0x1>
     118:	80 93 89 01 	sts	0x0189, r24	; 0x800189 <g_unAdcValue>
		*제일 중요한것은 hihg,low value는 기본적으로 8비트인데 ADCvalue가 16비트이기때문에 대입연산으로 인해 묵시적 형변환이 생겨
		high,low value는 둘다 16비트로 변환이 되어 or연산을 해주어 비트의 자리를 이동 시킬수 있게 해준다. 만일 8비트씩 자리이동과
		or을 한다면 8번 왼쪽으로 옴긴결과는 그 8비트를 넘어가기때문에 그 비트의 수를 버리게된다!* */
	}
	//sei();
}
     11c:	9f 91       	pop	r25
     11e:	8f 91       	pop	r24
     120:	2f 91       	pop	r18
     122:	0f 90       	pop	r0
     124:	0f be       	out	0x3f, r0	; 63
     126:	0f 90       	pop	r0
     128:	1f 90       	pop	r1
     12a:	18 95       	reti

0000012c <__vector_30>:
	while(!(UCSR0A & 0x20)); // 이전에 송신한 데이터가 아직 송신 중이면 대기
	UDR0 = BUF;
	
}*/
ISR(USART1_RX_vect)
{
     12c:	1f 92       	push	r1
     12e:	0f 92       	push	r0
     130:	0f b6       	in	r0, 0x3f	; 63
     132:	0f 92       	push	r0
     134:	11 24       	eor	r1, r1
     136:	0b b6       	in	r0, 0x3b	; 59
     138:	0f 92       	push	r0
     13a:	2f 93       	push	r18
     13c:	3f 93       	push	r19
     13e:	4f 93       	push	r20
     140:	5f 93       	push	r21
     142:	6f 93       	push	r22
     144:	7f 93       	push	r23
     146:	8f 93       	push	r24
     148:	9f 93       	push	r25
     14a:	af 93       	push	r26
     14c:	bf 93       	push	r27
     14e:	cf 93       	push	r28
     150:	df 93       	push	r29
     152:	ef 93       	push	r30
     154:	ff 93       	push	r31
	
	
	RX = UDR1;                                                //GPS데이터를 1byte씩 RX변수에 저장
     156:	80 91 9c 00 	lds	r24, 0x009C	; 0x80009c <__TEXT_REGION_LENGTH__+0x7e009c>
     15a:	80 93 f1 01 	sts	0x01F1, r24	; 0x8001f1 <RX>
	
	if(RX == '$')                                             //시작 바이트가 '$'일 경우를 판별 맞으면
     15e:	80 91 f1 01 	lds	r24, 0x01F1	; 0x8001f1 <RX>
     162:	84 32       	cpi	r24, 0x24	; 36
     164:	49 f4       	brne	.+18     	; 0x178 <__vector_30+0x4c>
	{
		GPS_DATA[0] = '$';                                    //배열의 0번째 자리에 '$'를 저장
     166:	80 93 bf 02 	sts	0x02BF, r24	; 0x8002bf <GPS_DATA>
		GPScnt = 1;                                           //배열의 카운터를 1증가
     16a:	81 e0       	ldi	r24, 0x01	; 1
     16c:	90 e0       	ldi	r25, 0x00	; 0
     16e:	90 93 f6 01 	sts	0x01F6, r25	; 0x8001f6 <GPScnt+0x1>
     172:	80 93 f5 01 	sts	0x01F5, r24	; 0x8001f5 <GPScnt>
     176:	ea c0       	rjmp	.+468    	; 0x34c <__vector_30+0x220>
	}
	else                                                      //시작 바이트 '$'다음부터
	{
		GPS_DATA[GPScnt] = RX;                                //배열에 수신된 GPS데이터를 저장
     178:	c0 91 f5 01 	lds	r28, 0x01F5	; 0x8001f5 <GPScnt>
     17c:	d0 91 f6 01 	lds	r29, 0x01F6	; 0x8001f6 <GPScnt+0x1>
     180:	80 91 f1 01 	lds	r24, 0x01F1	; 0x8001f1 <RX>
     184:	fe 01       	movw	r30, r28
     186:	e1 54       	subi	r30, 0x41	; 65
     188:	fd 4f       	sbci	r31, 0xFD	; 253
     18a:	80 83       	st	Z, r24
		
		if(GPS_DATA[GPScnt] == 0x0A)                          //수신된 데이터가 End Byte 0x0A='\n'일 경우
     18c:	8a 30       	cpi	r24, 0x0A	; 10
     18e:	09 f0       	breq	.+2      	; 0x192 <__vector_30+0x66>
     190:	d4 c0       	rjmp	.+424    	; 0x33a <__vector_30+0x20e>
		{
			GPScnt1 = GPScnt;                                 //수신된 문자열 카운터를 다른 변수에 저장
     192:	d0 93 f0 01 	sts	0x01F0, r29	; 0x8001f0 <GPScnt1+0x1>
     196:	c0 93 ef 01 	sts	0x01EF, r28	; 0x8001ef <GPScnt1>
			if(strncmp(NAME,GPS_DATA,6) == 0)                 //배열의 6번째 자리까지 문자열 "GPGGA"와 비교, 맞으면
     19a:	46 e0       	ldi	r20, 0x06	; 6
     19c:	50 e0       	ldi	r21, 0x00	; 0
     19e:	6f eb       	ldi	r22, 0xBF	; 191
     1a0:	72 e0       	ldi	r23, 0x02	; 2
     1a2:	8a e1       	ldi	r24, 0x1A	; 26
     1a4:	91 e0       	ldi	r25, 0x01	; 1
     1a6:	43 d7       	rcall	.+3718   	; 0x102e <strncmp>
     1a8:	89 2b       	or	r24, r25
     1aa:	d1 f5       	brne	.+116    	; 0x220 <__vector_30+0xf4>
			{
				memmove(GPS_DATA1,GPS_DATA,GPScnt1);          /*GPS_DATA1 배열에 메모리 복사하여 저장 strncpy 와 비슷한데, memmove로 사용가능, memcpy와도 같은기능
     1ac:	ae 01       	movw	r20, r28
     1ae:	6f eb       	ldi	r22, 0xBF	; 191
     1b0:	72 e0       	ldi	r23, 0x02	; 2
     1b2:	87 ef       	ldi	r24, 0xF7	; 247
     1b4:	91 e0       	ldi	r25, 0x01	; 1
     1b6:	2b d7       	rcall	.+3670   	; 0x100e <memcpy>
																memmove (move+1,move1+1,3) 이런식으면 move1(원본) +1주소부터 move(사본)+1주소에 3만큼 복사하겠다는것*/
				GPS_cut = strtok(GPS_DATA1,",");              /*GPS_Data1의 구분자 ','의 첫번째 주소값을 null로 변경 하여 
     1b8:	67 e2       	ldi	r22, 0x27	; 39
     1ba:	71 e0       	ldi	r23, 0x01	; 1
     1bc:	87 ef       	ldi	r24, 0xF7	; 247
     1be:	91 e0       	ldi	r25, 0x01	; 1
     1c0:	23 d7       	rcall	.+3654   	; 0x1008 <strtok>
     1c2:	80 93 86 01 	sts	0x0186, r24	; 0x800186 <GPS_cut>
     1c6:	90 93 87 01 	sts	0x0187, r25	; 0x800187 <GPS_cut+0x1>
																반환 즉, GPS_DATA1이 첫주소부터','을 만나기 전까지 체크하여 ','을 만나자마자 바로 첫주소를 반환
																','을 null로 변환해주는것!*/
				for(i=0; GPS_cut!=null; i++)                  //null이 없을때까지
     1ca:	10 92 f3 01 	sts	0x01F3, r1	; 0x8001f3 <i+0x1>
     1ce:	10 92 f2 01 	sts	0x01F2, r1	; 0x8001f2 <i>
     1d2:	28 2f       	mov	r18, r24
     1d4:	39 2f       	mov	r19, r25
     1d6:	21 15       	cp	r18, r1
     1d8:	31 05       	cpc	r19, r1
     1da:	11 f1       	breq	.+68     	; 0x220 <__vector_30+0xf4>
				{
					GPS_Dcut[i] = GPS_cut;                    /*포인트변수 GPS_DATA1의 첫 주소를 바로 Dcut 포인터배열에 반환, Dcut은 ','만나기전 첫 주소를 가리
     1dc:	e0 91 f2 01 	lds	r30, 0x01F2	; 0x8001f2 <i>
     1e0:	f0 91 f3 01 	lds	r31, 0x01F3	; 0x8001f3 <i+0x1>
     1e4:	ee 0f       	add	r30, r30
     1e6:	ff 1f       	adc	r31, r31
     1e8:	e8 59       	subi	r30, 0x98	; 152
     1ea:	fe 4f       	sbci	r31, 0xFE	; 254
     1ec:	31 83       	std	Z+1, r19	; 0x01
     1ee:	20 83       	st	Z, r18
																키고있다! null이 있을때 마다 i를 증가 시켜 주소값을 반환하여 GPS_Dcut배열에 저장*/
					GPS_cut = strtok(null,",");               //null의 첫번째 직후 주소값부터, ','이후 ','만나기전까지 확인하고, ','이후의 첫 주소를 반환!
     1f0:	67 e2       	ldi	r22, 0x27	; 39
     1f2:	71 e0       	ldi	r23, 0x01	; 1
     1f4:	80 e0       	ldi	r24, 0x00	; 0
     1f6:	90 e0       	ldi	r25, 0x00	; 0
     1f8:	07 d7       	rcall	.+3598   	; 0x1008 <strtok>
     1fa:	80 93 86 01 	sts	0x0186, r24	; 0x800186 <GPS_cut>
     1fe:	90 93 87 01 	sts	0x0187, r25	; 0x800187 <GPS_cut+0x1>
				memmove(GPS_DATA1,GPS_DATA,GPScnt1);          /*GPS_DATA1 배열에 메모리 복사하여 저장 strncpy 와 비슷한데, memmove로 사용가능, memcpy와도 같은기능
																memmove (move+1,move1+1,3) 이런식으면 move1(원본) +1주소부터 move(사본)+1주소에 3만큼 복사하겠다는것*/
				GPS_cut = strtok(GPS_DATA1,",");              /*GPS_Data1의 구분자 ','의 첫번째 주소값을 null로 변경 하여 
																반환 즉, GPS_DATA1이 첫주소부터','을 만나기 전까지 체크하여 ','을 만나자마자 바로 첫주소를 반환
																','을 null로 변환해주는것!*/
				for(i=0; GPS_cut!=null; i++)                  //null이 없을때까지
     202:	20 91 f2 01 	lds	r18, 0x01F2	; 0x8001f2 <i>
     206:	30 91 f3 01 	lds	r19, 0x01F3	; 0x8001f3 <i+0x1>
     20a:	2f 5f       	subi	r18, 0xFF	; 255
     20c:	3f 4f       	sbci	r19, 0xFF	; 255
     20e:	30 93 f3 01 	sts	0x01F3, r19	; 0x8001f3 <i+0x1>
     212:	20 93 f2 01 	sts	0x01F2, r18	; 0x8001f2 <i>
     216:	28 2f       	mov	r18, r24
     218:	39 2f       	mov	r19, r25
     21a:	21 15       	cp	r18, r1
     21c:	31 05       	cpc	r19, r1
     21e:	f1 f6       	brne	.-68     	; 0x1dc <__vector_30+0xb0>
					GPS_Dcut[i] = GPS_cut;                    /*포인트변수 GPS_DATA1의 첫 주소를 바로 Dcut 포인터배열에 반환, Dcut은 ','만나기전 첫 주소를 가리
																키고있다! null이 있을때 마다 i를 증가 시켜 주소값을 반환하여 GPS_Dcut배열에 저장*/
					GPS_cut = strtok(null,",");               //null의 첫번째 직후 주소값부터, ','이후 ','만나기전까지 확인하고, ','이후의 첫 주소를 반환!
				}
			}
			if(strncmp(NAME1,GPS_DATA,6) == 0)
     220:	46 e0       	ldi	r20, 0x06	; 6
     222:	50 e0       	ldi	r21, 0x00	; 0
     224:	6f eb       	ldi	r22, 0xBF	; 191
     226:	72 e0       	ldi	r23, 0x02	; 2
     228:	80 e1       	ldi	r24, 0x10	; 16
     22a:	91 e0       	ldi	r25, 0x01	; 1
     22c:	00 d7       	rcall	.+3584   	; 0x102e <strncmp>
     22e:	89 2b       	or	r24, r25
     230:	09 f0       	breq	.+2      	; 0x234 <__vector_30+0x108>
     232:	3d c0       	rjmp	.+122    	; 0x2ae <__vector_30+0x182>
			{
				memmove(GPS_DATA2,GPS_DATA,GPScnt1);
     234:	40 91 ef 01 	lds	r20, 0x01EF	; 0x8001ef <GPScnt1>
     238:	50 91 f0 01 	lds	r21, 0x01F0	; 0x8001f0 <GPScnt1+0x1>
     23c:	6f eb       	ldi	r22, 0xBF	; 191
     23e:	72 e0       	ldi	r23, 0x02	; 2
     240:	8b e5       	ldi	r24, 0x5B	; 91
     242:	92 e0       	ldi	r25, 0x02	; 2
     244:	e4 d6       	rcall	.+3528   	; 0x100e <memcpy>
				GPS_cut = strtok(GPS_DATA2,",");
     246:	67 e2       	ldi	r22, 0x27	; 39
     248:	71 e0       	ldi	r23, 0x01	; 1
     24a:	8b e5       	ldi	r24, 0x5B	; 91
     24c:	92 e0       	ldi	r25, 0x02	; 2
     24e:	dc d6       	rcall	.+3512   	; 0x1008 <strtok>
     250:	80 93 86 01 	sts	0x0186, r24	; 0x800186 <GPS_cut>
     254:	90 93 87 01 	sts	0x0187, r25	; 0x800187 <GPS_cut+0x1>
				for(i=0; GPS_cut!=null; i++)
     258:	10 92 f3 01 	sts	0x01F3, r1	; 0x8001f3 <i+0x1>
     25c:	10 92 f2 01 	sts	0x01F2, r1	; 0x8001f2 <i>
     260:	28 2f       	mov	r18, r24
     262:	39 2f       	mov	r19, r25
     264:	21 15       	cp	r18, r1
     266:	31 05       	cpc	r19, r1
     268:	11 f1       	breq	.+68     	; 0x2ae <__vector_30+0x182>
				{
					GPS_Dcut1[i] = GPS_cut;
     26a:	e0 91 f2 01 	lds	r30, 0x01F2	; 0x8001f2 <i>
     26e:	f0 91 f3 01 	lds	r31, 0x01F3	; 0x8001f3 <i+0x1>
     272:	ee 0f       	add	r30, r30
     274:	ff 1f       	adc	r31, r31
     276:	e6 5b       	subi	r30, 0xB6	; 182
     278:	fe 4f       	sbci	r31, 0xFE	; 254
     27a:	31 83       	std	Z+1, r19	; 0x01
     27c:	20 83       	st	Z, r18
					GPS_cut = strtok(null,",");
     27e:	67 e2       	ldi	r22, 0x27	; 39
     280:	71 e0       	ldi	r23, 0x01	; 1
     282:	80 e0       	ldi	r24, 0x00	; 0
     284:	90 e0       	ldi	r25, 0x00	; 0
     286:	c0 d6       	rcall	.+3456   	; 0x1008 <strtok>
     288:	80 93 86 01 	sts	0x0186, r24	; 0x800186 <GPS_cut>
     28c:	90 93 87 01 	sts	0x0187, r25	; 0x800187 <GPS_cut+0x1>
			}
			if(strncmp(NAME1,GPS_DATA,6) == 0)
			{
				memmove(GPS_DATA2,GPS_DATA,GPScnt1);
				GPS_cut = strtok(GPS_DATA2,",");
				for(i=0; GPS_cut!=null; i++)
     290:	20 91 f2 01 	lds	r18, 0x01F2	; 0x8001f2 <i>
     294:	30 91 f3 01 	lds	r19, 0x01F3	; 0x8001f3 <i+0x1>
     298:	2f 5f       	subi	r18, 0xFF	; 255
     29a:	3f 4f       	sbci	r19, 0xFF	; 255
     29c:	30 93 f3 01 	sts	0x01F3, r19	; 0x8001f3 <i+0x1>
     2a0:	20 93 f2 01 	sts	0x01F2, r18	; 0x8001f2 <i>
     2a4:	28 2f       	mov	r18, r24
     2a6:	39 2f       	mov	r19, r25
     2a8:	21 15       	cp	r18, r1
     2aa:	31 05       	cpc	r19, r1
     2ac:	f1 f6       	brne	.-68     	; 0x26a <__vector_30+0x13e>
				{
					GPS_Dcut1[i] = GPS_cut;
					GPS_cut = strtok(null,",");
				}
			}
			if(strncmp(NAME2,GPS_DATA,GPScnt1) == 0)
     2ae:	c0 91 ef 01 	lds	r28, 0x01EF	; 0x8001ef <GPScnt1>
     2b2:	d0 91 f0 01 	lds	r29, 0x01F0	; 0x8001f0 <GPScnt1+0x1>
     2b6:	ae 01       	movw	r20, r28
     2b8:	6f eb       	ldi	r22, 0xBF	; 191
     2ba:	72 e0       	ldi	r23, 0x02	; 2
     2bc:	86 e0       	ldi	r24, 0x06	; 6
     2be:	91 e0       	ldi	r25, 0x01	; 1
     2c0:	b6 d6       	rcall	.+3436   	; 0x102e <strncmp>
     2c2:	89 2b       	or	r24, r25
     2c4:	d1 f5       	brne	.+116    	; 0x33a <__vector_30+0x20e>
			{
				memmove(GPS_DATA3,GPS_DATA,GPScnt1);
     2c6:	ae 01       	movw	r20, r28
     2c8:	6f eb       	ldi	r22, 0xBF	; 191
     2ca:	72 e0       	ldi	r23, 0x02	; 2
     2cc:	8b e8       	ldi	r24, 0x8B	; 139
     2ce:	91 e0       	ldi	r25, 0x01	; 1
     2d0:	9e d6       	rcall	.+3388   	; 0x100e <memcpy>
				GPS_cut = strtok(GPS_DATA3,",");
     2d2:	67 e2       	ldi	r22, 0x27	; 39
     2d4:	71 e0       	ldi	r23, 0x01	; 1
     2d6:	8b e8       	ldi	r24, 0x8B	; 139
     2d8:	91 e0       	ldi	r25, 0x01	; 1
     2da:	96 d6       	rcall	.+3372   	; 0x1008 <strtok>
     2dc:	80 93 86 01 	sts	0x0186, r24	; 0x800186 <GPS_cut>
     2e0:	90 93 87 01 	sts	0x0187, r25	; 0x800187 <GPS_cut+0x1>
				for(i=0; GPS_cut!=null; i++)
     2e4:	10 92 f3 01 	sts	0x01F3, r1	; 0x8001f3 <i+0x1>
     2e8:	10 92 f2 01 	sts	0x01F2, r1	; 0x8001f2 <i>
     2ec:	28 2f       	mov	r18, r24
     2ee:	39 2f       	mov	r19, r25
     2f0:	21 15       	cp	r18, r1
     2f2:	31 05       	cpc	r19, r1
     2f4:	11 f1       	breq	.+68     	; 0x33a <__vector_30+0x20e>
				{
					GPS_Dcut2[i] = GPS_cut;
     2f6:	e0 91 f2 01 	lds	r30, 0x01F2	; 0x8001f2 <i>
     2fa:	f0 91 f3 01 	lds	r31, 0x01F3	; 0x8001f3 <i+0x1>
     2fe:	ee 0f       	add	r30, r30
     300:	ff 1f       	adc	r31, r31
     302:	e4 5d       	subi	r30, 0xD4	; 212
     304:	fe 4f       	sbci	r31, 0xFE	; 254
     306:	31 83       	std	Z+1, r19	; 0x01
     308:	20 83       	st	Z, r18
					GPS_cut = strtok(null,",");
     30a:	67 e2       	ldi	r22, 0x27	; 39
     30c:	71 e0       	ldi	r23, 0x01	; 1
     30e:	80 e0       	ldi	r24, 0x00	; 0
     310:	90 e0       	ldi	r25, 0x00	; 0
     312:	7a d6       	rcall	.+3316   	; 0x1008 <strtok>
     314:	80 93 86 01 	sts	0x0186, r24	; 0x800186 <GPS_cut>
     318:	90 93 87 01 	sts	0x0187, r25	; 0x800187 <GPS_cut+0x1>
			}
			if(strncmp(NAME2,GPS_DATA,GPScnt1) == 0)
			{
				memmove(GPS_DATA3,GPS_DATA,GPScnt1);
				GPS_cut = strtok(GPS_DATA3,",");
				for(i=0; GPS_cut!=null; i++)
     31c:	20 91 f2 01 	lds	r18, 0x01F2	; 0x8001f2 <i>
     320:	30 91 f3 01 	lds	r19, 0x01F3	; 0x8001f3 <i+0x1>
     324:	2f 5f       	subi	r18, 0xFF	; 255
     326:	3f 4f       	sbci	r19, 0xFF	; 255
     328:	30 93 f3 01 	sts	0x01F3, r19	; 0x8001f3 <i+0x1>
     32c:	20 93 f2 01 	sts	0x01F2, r18	; 0x8001f2 <i>
     330:	28 2f       	mov	r18, r24
     332:	39 2f       	mov	r19, r25
     334:	21 15       	cp	r18, r1
     336:	31 05       	cpc	r19, r1
     338:	f1 f6       	brne	.-68     	; 0x2f6 <__vector_30+0x1ca>
					GPS_Dcut2[i] = GPS_cut;
					GPS_cut = strtok(null,",");
				}
			}
		}
		GPScnt++;
     33a:	80 91 f5 01 	lds	r24, 0x01F5	; 0x8001f5 <GPScnt>
     33e:	90 91 f6 01 	lds	r25, 0x01F6	; 0x8001f6 <GPScnt+0x1>
     342:	01 96       	adiw	r24, 0x01	; 1
     344:	90 93 f6 01 	sts	0x01F6, r25	; 0x8001f6 <GPScnt+0x1>
     348:	80 93 f5 01 	sts	0x01F5, r24	; 0x8001f5 <GPScnt>
	}
	
}
     34c:	ff 91       	pop	r31
     34e:	ef 91       	pop	r30
     350:	df 91       	pop	r29
     352:	cf 91       	pop	r28
     354:	bf 91       	pop	r27
     356:	af 91       	pop	r26
     358:	9f 91       	pop	r25
     35a:	8f 91       	pop	r24
     35c:	7f 91       	pop	r23
     35e:	6f 91       	pop	r22
     360:	5f 91       	pop	r21
     362:	4f 91       	pop	r20
     364:	3f 91       	pop	r19
     366:	2f 91       	pop	r18
     368:	0f 90       	pop	r0
     36a:	0b be       	out	0x3b, r0	; 59
     36c:	0f 90       	pop	r0
     36e:	0f be       	out	0x3f, r0	; 63
     370:	0f 90       	pop	r0
     372:	1f 90       	pop	r1
     374:	18 95       	reti

00000376 <uart_set>:

void uart_set(void) //USART0은 GPS수신용 혹은 블루투스 수신용, USART1은 PC와와의 하이퍼 터미널을 위한것
{
	UBRR0H = 0;
     376:	10 92 90 00 	sts	0x0090, r1	; 0x800090 <__TEXT_REGION_LENGTH__+0x7e0090>
	UBRR0L = 103; //전송속도는 9600bps
     37a:	27 e6       	ldi	r18, 0x67	; 103
     37c:	29 b9       	out	0x09, r18	; 9
	UCSR0A = 0x00;
     37e:	1b b8       	out	0x0b, r1	; 11
	UCSR0B = 0x98; // 수신완료 인터럽트 허용, receiver와 transmitter 허용
     380:	98 e9       	ldi	r25, 0x98	; 152
     382:	9a b9       	out	0x0a, r25	; 10
	UCSR0C = 0x06; // 8bit 단위 송수신
     384:	86 e0       	ldi	r24, 0x06	; 6
     386:	80 93 95 00 	sts	0x0095, r24	; 0x800095 <__TEXT_REGION_LENGTH__+0x7e0095>
	
	UBRR1H = 0;
     38a:	10 92 98 00 	sts	0x0098, r1	; 0x800098 <__TEXT_REGION_LENGTH__+0x7e0098>
	UBRR1L = 103; //전송속도는 9600bps
     38e:	20 93 99 00 	sts	0x0099, r18	; 0x800099 <__TEXT_REGION_LENGTH__+0x7e0099>
	UCSR1A = 0x00;
     392:	10 92 9b 00 	sts	0x009B, r1	; 0x80009b <__TEXT_REGION_LENGTH__+0x7e009b>
	UCSR1B = 0x98; // receiver와 transmitter 허용
     396:	90 93 9a 00 	sts	0x009A, r25	; 0x80009a <__TEXT_REGION_LENGTH__+0x7e009a>
	UCSR1C = 0x06; // 8bit 단위 송수신
     39a:	80 93 9d 00 	sts	0x009D, r24	; 0x80009d <__TEXT_REGION_LENGTH__+0x7e009d>
     39e:	08 95       	ret

000003a0 <ADC_Init>:
}

void ADC_Init()
{
	// Internal 2.56V Voltage Reference with external capacitor at AREF pin
	ADMUX	=	0xC1;     	/* ADC1 Channel, ADC멀티플랙서 선택 레지스터 0~4비트까지 mux0~mux4로 즉 1100 0001 0비트의 mux0을 선택
     3a0:	81 ec       	ldi	r24, 0xC1	; 193
     3a2:	87 b9       	out	0x07, r24	; 7
								7비트, 6비트의 REFS1, REFS0 을 11로 주어 2.56v를 써줌. , 5비트의 ADLAR에 0을 주어 우정렬을 함. */	

	// ADC Module Enable, Free Running Mode, ADC Prescaler : 64
	ADCSRA	=	0xA6;	/* ADC제어/상태 레지스터로 1010 0110 7비트인 ADEN에 1을 주어 ADC를 허용 하고, ADFR에 1을 주어 free running 모드로 
     3a4:	86 ea       	ldi	r24, 0xA6	; 166
     3a6:	86 b9       	out	0x06, r24	; 6
							동작, ADPS0~2 까지 총 3비트에 110을 주어 64번으로 분주해 샘플링 .*/
	ADCSRA	|=	0x40;	/* ADC start conversion 0100 0000 or 해서 0100 0000 즉 ADSC비트에 1을 주어서 free running 모드에서 첫 번째 변환을 시작 하기
     3a8:	36 9a       	sbi	0x06, 6	; 6
     3aa:	08 95       	ret

000003ac <print_String_a>:

void print_String_a ( char *tring ) /*문자열. char string에 main에 있는 "Hello MCU World!" 라는 문자열이 매개변수로 들어온다.
									hello mcu world라는 것은 string이라는 변수에 배열처럼 작용을 한다. 즉 string이라는 번지에 H라는
									값이 들어가고, string+1이라는 번지에 e, string+2라는 번지에 l 등등으로 들어가 !까지 배열처럼
									값으로 들어가고, ! 다음에는 \0의 값이 마지막 번지로 들어가 종료를 의미한다.*/
{
     3ac:	fc 01       	movw	r30, r24
	UDR0 = 'L';
     3ae:	8c e4       	ldi	r24, 0x4C	; 76
     3b0:	8c b9       	out	0x0c, r24	; 12
	UDR0 = 'a';
     3b2:	81 e6       	ldi	r24, 0x61	; 97
     3b4:	8c b9       	out	0x0c, r24	; 12
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
     3b6:	2f ef       	ldi	r18, 0xFF	; 255
     3b8:	81 ee       	ldi	r24, 0xE1	; 225
     3ba:	94 e0       	ldi	r25, 0x04	; 4
     3bc:	21 50       	subi	r18, 0x01	; 1
     3be:	80 40       	sbci	r24, 0x00	; 0
     3c0:	90 40       	sbci	r25, 0x00	; 0
     3c2:	e1 f7       	brne	.-8      	; 0x3bc <print_String_a+0x10>
     3c4:	00 c0       	rjmp	.+0      	; 0x3c6 <print_String_a+0x1a>
     3c6:	00 00       	nop
	_delay_ms(100);
	UDR0 = ':';
     3c8:	8a e3       	ldi	r24, 0x3A	; 58
     3ca:	8c b9       	out	0x0c, r24	; 12
     3cc:	8f e9       	ldi	r24, 0x9F	; 159
     3ce:	9c e8       	ldi	r25, 0x8C	; 140
     3d0:	01 97       	sbiw	r24, 0x01	; 1
     3d2:	f1 f7       	brne	.-4      	; 0x3d0 <print_String_a+0x24>
     3d4:	00 c0       	rjmp	.+0      	; 0x3d6 <print_String_a+0x2a>
     3d6:	00 00       	nop
	_delay_ms(9);
	while ( *tring != '\0' )	/* string의 포인트 즉 string번지의 값이 \0 이 아니면 while의 조건에 맞아 다음을 실행하고,
     3d8:	90 81       	ld	r25, Z
     3da:	99 23       	and	r25, r25
     3dc:	71 f0       	breq	.+28     	; 0x3fa <print_String_a+0x4e>
     3de:	31 96       	adiw	r30, 0x01	; 1
									을 string의 번지수의 값을 넣고 e=1이 였다가 다음 e=0인 순간 입력을 받아 LCD로 표현한다.*/
	{
						/*string의 번지를 +1씩 추가하여 다음 번지의 포인트 조건에 맞아 값을 출력 즉 처음에 H를 찍어냈으면 다음에는
								E, L L O 이런식으로 하기 위하여 ++을 함. */
		
		UDR0 = (*tring);
     3e0:	9c b9       	out	0x0c, r25	; 12
     3e2:	9f ef       	ldi	r25, 0xFF	; 255
     3e4:	21 ee       	ldi	r18, 0xE1	; 225
     3e6:	84 e0       	ldi	r24, 0x04	; 4
     3e8:	91 50       	subi	r25, 0x01	; 1
     3ea:	20 40       	sbci	r18, 0x00	; 0
     3ec:	80 40       	sbci	r24, 0x00	; 0
     3ee:	e1 f7       	brne	.-8      	; 0x3e8 <print_String_a+0x3c>
     3f0:	00 c0       	rjmp	.+0      	; 0x3f2 <print_String_a+0x46>
     3f2:	00 00       	nop
	UDR0 = 'L';
	UDR0 = 'a';
	_delay_ms(100);
	UDR0 = ':';
	_delay_ms(9);
	while ( *tring != '\0' )	/* string의 포인트 즉 string번지의 값이 \0 이 아니면 while의 조건에 맞아 다음을 실행하고,
     3f4:	91 91       	ld	r25, Z+
     3f6:	91 11       	cpse	r25, r1
     3f8:	f3 cf       	rjmp	.-26     	; 0x3e0 <print_String_a+0x34>
		
		UDR0 = (*tring);
		tring ++;
		_delay_ms(100);
	}
	UDR0 = 32;
     3fa:	80 e2       	ldi	r24, 0x20	; 32
     3fc:	8c b9       	out	0x0c, r24	; 12
     3fe:	08 95       	ret

00000400 <print_String_b>:

void print_String_b ( char *tring ) /*문자열. char string에 main에 있는 "Hello MCU World!" 라는 문자열이 매개변수로 들어온다.
									hello mcu world라는 것은 string이라는 변수에 배열처럼 작용을 한다. 즉 string이라는 번지에 H라는
									값이 들어가고, string+1이라는 번지에 e, string+2라는 번지에 l 등등으로 들어가 !까지 배열처럼
									값으로 들어가고, ! 다음에는 \0의 값이 마지막 번지로 들어가 종료를 의미한다.*/
{
     400:	fc 01       	movw	r30, r24
	UDR0 = 'L';
     402:	8c e4       	ldi	r24, 0x4C	; 76
     404:	8c b9       	out	0x0c, r24	; 12
     406:	8f e9       	ldi	r24, 0x9F	; 159
     408:	9c e8       	ldi	r25, 0x8C	; 140
     40a:	01 97       	sbiw	r24, 0x01	; 1
     40c:	f1 f7       	brne	.-4      	; 0x40a <print_String_b+0xa>
     40e:	00 c0       	rjmp	.+0      	; 0x410 <print_String_b+0x10>
     410:	00 00       	nop
	_delay_ms(9);
	UDR0 = 'o';
     412:	8f e6       	ldi	r24, 0x6F	; 111
     414:	8c b9       	out	0x0c, r24	; 12
     416:	9f ef       	ldi	r25, 0xFF	; 255
     418:	21 ee       	ldi	r18, 0xE1	; 225
     41a:	84 e0       	ldi	r24, 0x04	; 4
     41c:	91 50       	subi	r25, 0x01	; 1
     41e:	20 40       	sbci	r18, 0x00	; 0
     420:	80 40       	sbci	r24, 0x00	; 0
     422:	e1 f7       	brne	.-8      	; 0x41c <print_String_b+0x1c>
     424:	00 c0       	rjmp	.+0      	; 0x426 <print_String_b+0x26>
     426:	00 00       	nop
	_delay_ms(100);
	UDR0 = ':';
     428:	8a e3       	ldi	r24, 0x3A	; 58
     42a:	8c b9       	out	0x0c, r24	; 12
     42c:	8f e9       	ldi	r24, 0x9F	; 159
     42e:	9c e8       	ldi	r25, 0x8C	; 140
     430:	01 97       	sbiw	r24, 0x01	; 1
     432:	f1 f7       	brne	.-4      	; 0x430 <print_String_b+0x30>
     434:	00 c0       	rjmp	.+0      	; 0x436 <print_String_b+0x36>
     436:	00 00       	nop
	_delay_ms(9);
	while ( *tring != '\0' )	/* string의 포인트 즉 string번지의 값이 \0 이 아니면 while의 조건에 맞아 다음을 실행하고,
     438:	90 81       	ld	r25, Z
     43a:	99 23       	and	r25, r25
     43c:	71 f0       	breq	.+28     	; 0x45a <print_String_b+0x5a>
     43e:	31 96       	adiw	r30, 0x01	; 1
									을 string의 번지수의 값을 넣고 e=1이 였다가 다음 e=0인 순간 입력을 받아 LCD로 표현한다.*/
	{
						/*string의 번지를 +1씩 추가하여 다음 번지의 포인트 조건에 맞아 값을 출력 즉 처음에 H를 찍어냈으면 다음에는
								E, L L O 이런식으로 하기 위하여 ++을 함. */
		
		UDR0 = (*tring);
     440:	9c b9       	out	0x0c, r25	; 12
     442:	9f ef       	ldi	r25, 0xFF	; 255
     444:	21 ee       	ldi	r18, 0xE1	; 225
     446:	84 e0       	ldi	r24, 0x04	; 4
     448:	91 50       	subi	r25, 0x01	; 1
     44a:	20 40       	sbci	r18, 0x00	; 0
     44c:	80 40       	sbci	r24, 0x00	; 0
     44e:	e1 f7       	brne	.-8      	; 0x448 <print_String_b+0x48>
     450:	00 c0       	rjmp	.+0      	; 0x452 <print_String_b+0x52>
     452:	00 00       	nop
	_delay_ms(9);
	UDR0 = 'o';
	_delay_ms(100);
	UDR0 = ':';
	_delay_ms(9);
	while ( *tring != '\0' )	/* string의 포인트 즉 string번지의 값이 \0 이 아니면 while의 조건에 맞아 다음을 실행하고,
     454:	91 91       	ld	r25, Z+
     456:	91 11       	cpse	r25, r1
     458:	f3 cf       	rjmp	.-26     	; 0x440 <print_String_b+0x40>
		
		UDR0 = (*tring);
		tring ++;
		_delay_ms(100);
	}
	UDR0 = 32;
     45a:	80 e2       	ldi	r24, 0x20	; 32
     45c:	8c b9       	out	0x0c, r24	; 12
     45e:	08 95       	ret

00000460 <main>:
{
	unsigned char ucLowValue	=	0; //ADC 변환 결과 값에서 ADCL 값을 저장할 변수를 선언
	unsigned char ucHighValue	=	0;	//ADC 변환 결과 값에서 ADCH 값을 저장할 변수를 선언.
	unsigned char line = 0;
	
	DDRE = 0x01; // PORTF 0번핀 출력설정
     460:	81 e0       	ldi	r24, 0x01	; 1
     462:	82 b9       	out	0x02, r24	; 2
	DDRD = 0x08; // PORTD 0번핀 입력설정
     464:	88 e0       	ldi	r24, 0x08	; 8
     466:	81 bb       	out	0x11, r24	; 17
     468:	8f e3       	ldi	r24, 0x3F	; 63
     46a:	9c e9       	ldi	r25, 0x9C	; 156
     46c:	01 97       	sbiw	r24, 0x01	; 1
     46e:	f1 f7       	brne	.-4      	; 0x46c <main+0xc>
     470:	00 c0       	rjmp	.+0      	; 0x472 <main+0x12>
     472:	00 00       	nop
	
	_delay_ms(10);
	NS_Rainbow_init(USELED, PB, 0);
     474:	40 e0       	ldi	r20, 0x00	; 0
     476:	68 e3       	ldi	r22, 0x38	; 56
     478:	80 e4       	ldi	r24, 0x40	; 64
     47a:	90 e0       	ldi	r25, 0x00	; 0
     47c:	02 d3       	rcall	.+1540   	; 0xa82 <NS_Rainbow_init>
	setBrightness(50); 	// 0,1(OFF) ~ 255
     47e:	82 e3       	ldi	r24, 0x32	; 50
     480:	7c d3       	rcall	.+1784   	; 0xb7a <setBrightness>

	TIMER_Init();
     482:	22 de       	rcall	.-956    	; 0xc8 <TIMER_Init>
	ADC_Init ();		// PORTF = ADC1
     484:	8d df       	rcall	.-230    	; 0x3a0 <ADC_Init>
	 
	 
	 uart_set();
     486:	77 df       	rcall	.-274    	; 0x376 <uart_set>
     488:	ef e1       	ldi	r30, 0x1F	; 31
     48a:	fe e4       	ldi	r31, 0x4E	; 78
     48c:	31 97       	sbiw	r30, 0x01	; 1
     48e:	f1 f7       	brne	.-4      	; 0x48c <main+0x2c>
     490:	00 c0       	rjmp	.+0      	; 0x492 <main+0x32>
     492:	00 00       	nop
	 _delay_ms(5);
	
	 sei();
     494:	78 94       	sei
	while (1)
	{
		
		print_String_a ( GPS_Dcut[2] );
     496:	0f 2e       	mov	r0, r31
     498:	f8 e6       	ldi	r31, 0x68	; 104
     49a:	ef 2e       	mov	r14, r31
     49c:	f1 e0       	ldi	r31, 0x01	; 1
     49e:	ff 2e       	mov	r15, r31
     4a0:	f0 2d       	mov	r31, r0
     4a2:	f7 01       	movw	r30, r14
     4a4:	84 81       	ldd	r24, Z+4	; 0x04
     4a6:	95 81       	ldd	r25, Z+5	; 0x05
     4a8:	81 df       	rcall	.-254    	; 0x3ac <print_String_a>
		print_String_b ( GPS_Dcut[4] );
     4aa:	f7 01       	movw	r30, r14
     4ac:	80 85       	ldd	r24, Z+8	; 0x08
     4ae:	91 85       	ldd	r25, Z+9	; 0x09
     4b0:	a7 df       	rcall	.-178    	; 0x400 <print_String_b>
		if((g_unAdcValue>900)&&(g_unAdcValue<=1000))
     4b2:	80 91 89 01 	lds	r24, 0x0189	; 0x800189 <g_unAdcValue>
     4b6:	90 91 8a 01 	lds	r25, 0x018A	; 0x80018a <g_unAdcValue+0x1>
     4ba:	9c 01       	movw	r18, r24
     4bc:	25 58       	subi	r18, 0x85	; 133
     4be:	33 40       	sbci	r19, 0x03	; 3
     4c0:	24 36       	cpi	r18, 0x64	; 100
     4c2:	31 05       	cpc	r19, r1
     4c4:	08 f0       	brcs	.+2      	; 0x4c8 <main+0x68>
     4c6:	4c c0       	rjmp	.+152    	; 0x560 <main+0x100>
     4c8:	18 e3       	ldi	r17, 0x38	; 56
		{
		
			for(int i = 7; i >= 0; i--)
			{
				line = i * 8;
				setColor_RGB(0 + line, 0xFF0000);			// RED
     4ca:	c1 2f       	mov	r28, r17
     4cc:	d0 e0       	ldi	r29, 0x00	; 0
     4ce:	40 e0       	ldi	r20, 0x00	; 0
     4d0:	50 e0       	ldi	r21, 0x00	; 0
     4d2:	6f ef       	ldi	r22, 0xFF	; 255
     4d4:	70 e0       	ldi	r23, 0x00	; 0
     4d6:	ce 01       	movw	r24, r28
     4d8:	00 d2       	rcall	.+1024   	; 0x8da <setColor_RGB>
				setColor_RGB(1 + line, 0xFF5E00);			// Orange
     4da:	40 e0       	ldi	r20, 0x00	; 0
     4dc:	5e e5       	ldi	r21, 0x5E	; 94
     4de:	6f ef       	ldi	r22, 0xFF	; 255
     4e0:	70 e0       	ldi	r23, 0x00	; 0
     4e2:	ce 01       	movw	r24, r28
     4e4:	01 96       	adiw	r24, 0x01	; 1
     4e6:	f9 d1       	rcall	.+1010   	; 0x8da <setColor_RGB>
				setColor_RGB(2 + line, 0xFFE400);			// Yellow
     4e8:	40 e0       	ldi	r20, 0x00	; 0
     4ea:	54 ee       	ldi	r21, 0xE4	; 228
     4ec:	6f ef       	ldi	r22, 0xFF	; 255
     4ee:	70 e0       	ldi	r23, 0x00	; 0
     4f0:	ce 01       	movw	r24, r28
     4f2:	02 96       	adiw	r24, 0x02	; 2
     4f4:	f2 d1       	rcall	.+996    	; 0x8da <setColor_RGB>
				setColor_RGB(3 + line, 0x1DDB16);			// Green
     4f6:	46 e1       	ldi	r20, 0x16	; 22
     4f8:	5b ed       	ldi	r21, 0xDB	; 219
     4fa:	6d e1       	ldi	r22, 0x1D	; 29
     4fc:	70 e0       	ldi	r23, 0x00	; 0
     4fe:	ce 01       	movw	r24, r28
     500:	03 96       	adiw	r24, 0x03	; 3
     502:	eb d1       	rcall	.+982    	; 0x8da <setColor_RGB>
				setColor_RGB(4 + line, 0x0000FF);			// Blue
     504:	4f ef       	ldi	r20, 0xFF	; 255
     506:	50 e0       	ldi	r21, 0x00	; 0
     508:	60 e0       	ldi	r22, 0x00	; 0
     50a:	70 e0       	ldi	r23, 0x00	; 0
     50c:	ce 01       	movw	r24, r28
     50e:	04 96       	adiw	r24, 0x04	; 4
     510:	e4 d1       	rcall	.+968    	; 0x8da <setColor_RGB>
				setColor_RGB(5 + line, 0x0100FF);			// Dark Blue
     512:	4f ef       	ldi	r20, 0xFF	; 255
     514:	50 e0       	ldi	r21, 0x00	; 0
     516:	61 e0       	ldi	r22, 0x01	; 1
     518:	70 e0       	ldi	r23, 0x00	; 0
     51a:	ce 01       	movw	r24, r28
     51c:	05 96       	adiw	r24, 0x05	; 5
     51e:	dd d1       	rcall	.+954    	; 0x8da <setColor_RGB>
				setColor_RGB(6 + line, 0x3F0099);			// Purple
     520:	49 e9       	ldi	r20, 0x99	; 153
     522:	50 e0       	ldi	r21, 0x00	; 0
     524:	6f e3       	ldi	r22, 0x3F	; 63
     526:	70 e0       	ldi	r23, 0x00	; 0
     528:	ce 01       	movw	r24, r28
     52a:	06 96       	adiw	r24, 0x06	; 6
     52c:	d6 d1       	rcall	.+940    	; 0x8da <setColor_RGB>
				show();
     52e:	43 d2       	rcall	.+1158   	; 0x9b6 <show>
     530:	ff ef       	ldi	r31, 0xFF	; 255
     532:	21 ee       	ldi	r18, 0xE1	; 225
     534:	84 e0       	ldi	r24, 0x04	; 4
     536:	f1 50       	subi	r31, 0x01	; 1
     538:	20 40       	sbci	r18, 0x00	; 0
     53a:	80 40       	sbci	r24, 0x00	; 0
     53c:	e1 f7       	brne	.-8      	; 0x536 <main+0xd6>
     53e:	00 c0       	rjmp	.+0      	; 0x540 <main+0xe0>
     540:	00 00       	nop
     542:	18 50       	subi	r17, 0x08	; 8
		print_String_a ( GPS_Dcut[2] );
		print_String_b ( GPS_Dcut[4] );
		if((g_unAdcValue>900)&&(g_unAdcValue<=1000))
		{
		
			for(int i = 7; i >= 0; i--)
     544:	18 3f       	cpi	r17, 0xF8	; 248
     546:	09 f0       	breq	.+2      	; 0x54a <main+0xea>
     548:	c0 cf       	rjmp	.-128    	; 0x4ca <main+0x6a>
     54a:	9f ef       	ldi	r25, 0xFF	; 255
     54c:	e9 e6       	ldi	r30, 0x69	; 105
     54e:	f8 e1       	ldi	r31, 0x18	; 24
     550:	91 50       	subi	r25, 0x01	; 1
     552:	e0 40       	sbci	r30, 0x00	; 0
     554:	f0 40       	sbci	r31, 0x00	; 0
     556:	e1 f7       	brne	.-8      	; 0x550 <main+0xf0>
     558:	00 c0       	rjmp	.+0      	; 0x55a <main+0xfa>
     55a:	00 00       	nop
				setColor_RGB(6 + line, 0x3F0099);			// Purple
				show();
				_delay_ms(100);
			}	
			_delay_ms(500);
			clear();
     55c:	01 d3       	rcall	.+1538   	; 0xb60 <clear>
     55e:	a1 cf       	rjmp	.-190    	; 0x4a2 <main+0x42>
		}
		else if((g_unAdcValue>800)&&(g_unAdcValue<=900))
     560:	9c 01       	movw	r18, r24
     562:	21 52       	subi	r18, 0x21	; 33
     564:	33 40       	sbci	r19, 0x03	; 3
     566:	24 36       	cpi	r18, 0x64	; 100
     568:	31 05       	cpc	r19, r1
     56a:	08 f0       	brcs	.+2      	; 0x56e <main+0x10e>
     56c:	44 c0       	rjmp	.+136    	; 0x5f6 <main+0x196>
     56e:	18 e3       	ldi	r17, 0x38	; 56
		{
		
			for(int i = 7; i >= 0; i--)
			{
				line = i * 8;
				setColor_RGB(0 + line, 0xFF0000);			// RED
     570:	c1 2f       	mov	r28, r17
     572:	d0 e0       	ldi	r29, 0x00	; 0
     574:	40 e0       	ldi	r20, 0x00	; 0
     576:	50 e0       	ldi	r21, 0x00	; 0
     578:	6f ef       	ldi	r22, 0xFF	; 255
     57a:	70 e0       	ldi	r23, 0x00	; 0
     57c:	ce 01       	movw	r24, r28
     57e:	ad d1       	rcall	.+858    	; 0x8da <setColor_RGB>
				setColor_RGB(1 + line, 0xFF5E00);			// Orange
     580:	40 e0       	ldi	r20, 0x00	; 0
     582:	5e e5       	ldi	r21, 0x5E	; 94
     584:	6f ef       	ldi	r22, 0xFF	; 255
     586:	70 e0       	ldi	r23, 0x00	; 0
     588:	ce 01       	movw	r24, r28
     58a:	01 96       	adiw	r24, 0x01	; 1
     58c:	a6 d1       	rcall	.+844    	; 0x8da <setColor_RGB>
				setColor_RGB(2 + line, 0xFFE400);			// Yellow
     58e:	40 e0       	ldi	r20, 0x00	; 0
     590:	54 ee       	ldi	r21, 0xE4	; 228
     592:	6f ef       	ldi	r22, 0xFF	; 255
     594:	70 e0       	ldi	r23, 0x00	; 0
     596:	ce 01       	movw	r24, r28
     598:	02 96       	adiw	r24, 0x02	; 2
     59a:	9f d1       	rcall	.+830    	; 0x8da <setColor_RGB>
				setColor_RGB(3 + line, 0x1DDB16);			// Green
     59c:	46 e1       	ldi	r20, 0x16	; 22
     59e:	5b ed       	ldi	r21, 0xDB	; 219
     5a0:	6d e1       	ldi	r22, 0x1D	; 29
     5a2:	70 e0       	ldi	r23, 0x00	; 0
     5a4:	ce 01       	movw	r24, r28
     5a6:	03 96       	adiw	r24, 0x03	; 3
     5a8:	98 d1       	rcall	.+816    	; 0x8da <setColor_RGB>
				setColor_RGB(4 + line, 0x0000FF);			// Blue
     5aa:	4f ef       	ldi	r20, 0xFF	; 255
     5ac:	50 e0       	ldi	r21, 0x00	; 0
     5ae:	60 e0       	ldi	r22, 0x00	; 0
     5b0:	70 e0       	ldi	r23, 0x00	; 0
     5b2:	ce 01       	movw	r24, r28
     5b4:	04 96       	adiw	r24, 0x04	; 4
     5b6:	91 d1       	rcall	.+802    	; 0x8da <setColor_RGB>
				setColor_RGB(5 + line, 0x0100FF);			// Dark Blue
     5b8:	4f ef       	ldi	r20, 0xFF	; 255
     5ba:	50 e0       	ldi	r21, 0x00	; 0
     5bc:	61 e0       	ldi	r22, 0x01	; 1
     5be:	70 e0       	ldi	r23, 0x00	; 0
     5c0:	ce 01       	movw	r24, r28
     5c2:	05 96       	adiw	r24, 0x05	; 5
     5c4:	8a d1       	rcall	.+788    	; 0x8da <setColor_RGB>
				show();
     5c6:	f7 d1       	rcall	.+1006   	; 0x9b6 <show>
     5c8:	2f ef       	ldi	r18, 0xFF	; 255
     5ca:	81 ee       	ldi	r24, 0xE1	; 225
     5cc:	94 e0       	ldi	r25, 0x04	; 4
     5ce:	21 50       	subi	r18, 0x01	; 1
     5d0:	80 40       	sbci	r24, 0x00	; 0
     5d2:	90 40       	sbci	r25, 0x00	; 0
     5d4:	e1 f7       	brne	.-8      	; 0x5ce <main+0x16e>
     5d6:	00 c0       	rjmp	.+0      	; 0x5d8 <main+0x178>
     5d8:	00 00       	nop
     5da:	18 50       	subi	r17, 0x08	; 8
			clear();
		}
		else if((g_unAdcValue>800)&&(g_unAdcValue<=900))
		{
		
			for(int i = 7; i >= 0; i--)
     5dc:	18 3f       	cpi	r17, 0xF8	; 248
     5de:	41 f6       	brne	.-112    	; 0x570 <main+0x110>
     5e0:	ef ef       	ldi	r30, 0xFF	; 255
     5e2:	f9 e6       	ldi	r31, 0x69	; 105
     5e4:	28 e1       	ldi	r18, 0x18	; 24
     5e6:	e1 50       	subi	r30, 0x01	; 1
     5e8:	f0 40       	sbci	r31, 0x00	; 0
     5ea:	20 40       	sbci	r18, 0x00	; 0
     5ec:	e1 f7       	brne	.-8      	; 0x5e6 <main+0x186>
     5ee:	00 c0       	rjmp	.+0      	; 0x5f0 <main+0x190>
     5f0:	00 00       	nop
				setColor_RGB(5 + line, 0x0100FF);			// Dark Blue
				show();
				_delay_ms(100);
			}
			_delay_ms(500);
			clear();
     5f2:	b6 d2       	rcall	.+1388   	; 0xb60 <clear>
     5f4:	56 cf       	rjmp	.-340    	; 0x4a2 <main+0x42>
		}
		else if((g_unAdcValue>600)&&(g_unAdcValue<=800))
     5f6:	9c 01       	movw	r18, r24
     5f8:	29 55       	subi	r18, 0x59	; 89
     5fa:	32 40       	sbci	r19, 0x02	; 2
     5fc:	28 3c       	cpi	r18, 0xC8	; 200
     5fe:	31 05       	cpc	r19, r1
     600:	08 f0       	brcs	.+2      	; 0x604 <main+0x1a4>
     602:	3d c0       	rjmp	.+122    	; 0x67e <main+0x21e>
     604:	18 e3       	ldi	r17, 0x38	; 56
		{
		
			for(int i = 7; i >= 0; i--)
			{
				line = i * 8;
				setColor_RGB(0 + line, 0xFF0000);			// RED
     606:	c1 2f       	mov	r28, r17
     608:	d0 e0       	ldi	r29, 0x00	; 0
     60a:	40 e0       	ldi	r20, 0x00	; 0
     60c:	50 e0       	ldi	r21, 0x00	; 0
     60e:	6f ef       	ldi	r22, 0xFF	; 255
     610:	70 e0       	ldi	r23, 0x00	; 0
     612:	ce 01       	movw	r24, r28
     614:	62 d1       	rcall	.+708    	; 0x8da <setColor_RGB>
				setColor_RGB(1 + line, 0xFF5E00);			// Orange
     616:	40 e0       	ldi	r20, 0x00	; 0
     618:	5e e5       	ldi	r21, 0x5E	; 94
     61a:	6f ef       	ldi	r22, 0xFF	; 255
     61c:	70 e0       	ldi	r23, 0x00	; 0
     61e:	ce 01       	movw	r24, r28
     620:	01 96       	adiw	r24, 0x01	; 1
     622:	5b d1       	rcall	.+694    	; 0x8da <setColor_RGB>
				setColor_RGB(2 + line, 0xFFE400);			// Yellow
     624:	40 e0       	ldi	r20, 0x00	; 0
     626:	54 ee       	ldi	r21, 0xE4	; 228
     628:	6f ef       	ldi	r22, 0xFF	; 255
     62a:	70 e0       	ldi	r23, 0x00	; 0
     62c:	ce 01       	movw	r24, r28
     62e:	02 96       	adiw	r24, 0x02	; 2
     630:	54 d1       	rcall	.+680    	; 0x8da <setColor_RGB>
				setColor_RGB(3 + line, 0x1DDB16);			// Green
     632:	46 e1       	ldi	r20, 0x16	; 22
     634:	5b ed       	ldi	r21, 0xDB	; 219
     636:	6d e1       	ldi	r22, 0x1D	; 29
     638:	70 e0       	ldi	r23, 0x00	; 0
     63a:	ce 01       	movw	r24, r28
     63c:	03 96       	adiw	r24, 0x03	; 3
     63e:	4d d1       	rcall	.+666    	; 0x8da <setColor_RGB>
				setColor_RGB(4 + line, 0x0000FF);			// Blue
     640:	4f ef       	ldi	r20, 0xFF	; 255
     642:	50 e0       	ldi	r21, 0x00	; 0
     644:	60 e0       	ldi	r22, 0x00	; 0
     646:	70 e0       	ldi	r23, 0x00	; 0
     648:	ce 01       	movw	r24, r28
     64a:	04 96       	adiw	r24, 0x04	; 4
     64c:	46 d1       	rcall	.+652    	; 0x8da <setColor_RGB>
				show();
     64e:	b3 d1       	rcall	.+870    	; 0x9b6 <show>
     650:	8f ef       	ldi	r24, 0xFF	; 255
     652:	91 ee       	ldi	r25, 0xE1	; 225
     654:	e4 e0       	ldi	r30, 0x04	; 4
     656:	81 50       	subi	r24, 0x01	; 1
     658:	90 40       	sbci	r25, 0x00	; 0
     65a:	e0 40       	sbci	r30, 0x00	; 0
     65c:	e1 f7       	brne	.-8      	; 0x656 <main+0x1f6>
     65e:	00 c0       	rjmp	.+0      	; 0x660 <main+0x200>
     660:	00 00       	nop
     662:	18 50       	subi	r17, 0x08	; 8
			clear();
		}
		else if((g_unAdcValue>600)&&(g_unAdcValue<=800))
		{
		
			for(int i = 7; i >= 0; i--)
     664:	18 3f       	cpi	r17, 0xF8	; 248
     666:	79 f6       	brne	.-98     	; 0x606 <main+0x1a6>
     668:	ff ef       	ldi	r31, 0xFF	; 255
     66a:	29 e6       	ldi	r18, 0x69	; 105
     66c:	88 e1       	ldi	r24, 0x18	; 24
     66e:	f1 50       	subi	r31, 0x01	; 1
     670:	20 40       	sbci	r18, 0x00	; 0
     672:	80 40       	sbci	r24, 0x00	; 0
     674:	e1 f7       	brne	.-8      	; 0x66e <main+0x20e>
     676:	00 c0       	rjmp	.+0      	; 0x678 <main+0x218>
     678:	00 00       	nop
				setColor_RGB(4 + line, 0x0000FF);			// Blue
				show();
				_delay_ms(100);
			}
			_delay_ms(500);
			clear();
     67a:	72 d2       	rcall	.+1252   	; 0xb60 <clear>
     67c:	12 cf       	rjmp	.-476    	; 0x4a2 <main+0x42>
		}
		else if((g_unAdcValue>500)&&(g_unAdcValue<=600))
     67e:	9c 01       	movw	r18, r24
     680:	25 5f       	subi	r18, 0xF5	; 245
     682:	31 40       	sbci	r19, 0x01	; 1
     684:	24 36       	cpi	r18, 0x64	; 100
     686:	31 05       	cpc	r19, r1
     688:	b0 f5       	brcc	.+108    	; 0x6f6 <main+0x296>
     68a:	18 e3       	ldi	r17, 0x38	; 56
		{
			for(int i = 7; i >= 0; i--)
			{
				line = i * 8;
				setColor_RGB(0 + line, 0xFF0000);			// RED
     68c:	c1 2f       	mov	r28, r17
     68e:	d0 e0       	ldi	r29, 0x00	; 0
     690:	40 e0       	ldi	r20, 0x00	; 0
     692:	50 e0       	ldi	r21, 0x00	; 0
     694:	6f ef       	ldi	r22, 0xFF	; 255
     696:	70 e0       	ldi	r23, 0x00	; 0
     698:	ce 01       	movw	r24, r28
     69a:	1f d1       	rcall	.+574    	; 0x8da <setColor_RGB>
				setColor_RGB(1 + line, 0xFF5E00);			// Orange
     69c:	40 e0       	ldi	r20, 0x00	; 0
     69e:	5e e5       	ldi	r21, 0x5E	; 94
     6a0:	6f ef       	ldi	r22, 0xFF	; 255
     6a2:	70 e0       	ldi	r23, 0x00	; 0
     6a4:	ce 01       	movw	r24, r28
     6a6:	01 96       	adiw	r24, 0x01	; 1
     6a8:	18 d1       	rcall	.+560    	; 0x8da <setColor_RGB>
				setColor_RGB(2 + line, 0xFFE400);			// Yellow
     6aa:	40 e0       	ldi	r20, 0x00	; 0
     6ac:	54 ee       	ldi	r21, 0xE4	; 228
     6ae:	6f ef       	ldi	r22, 0xFF	; 255
     6b0:	70 e0       	ldi	r23, 0x00	; 0
     6b2:	ce 01       	movw	r24, r28
     6b4:	02 96       	adiw	r24, 0x02	; 2
     6b6:	11 d1       	rcall	.+546    	; 0x8da <setColor_RGB>
				setColor_RGB(3 + line, 0x1DDB16);			// Green
     6b8:	46 e1       	ldi	r20, 0x16	; 22
     6ba:	5b ed       	ldi	r21, 0xDB	; 219
     6bc:	6d e1       	ldi	r22, 0x1D	; 29
     6be:	70 e0       	ldi	r23, 0x00	; 0
     6c0:	ce 01       	movw	r24, r28
     6c2:	03 96       	adiw	r24, 0x03	; 3
     6c4:	0a d1       	rcall	.+532    	; 0x8da <setColor_RGB>
				show();
     6c6:	77 d1       	rcall	.+750    	; 0x9b6 <show>
     6c8:	9f ef       	ldi	r25, 0xFF	; 255
     6ca:	e1 ee       	ldi	r30, 0xE1	; 225
     6cc:	f4 e0       	ldi	r31, 0x04	; 4
     6ce:	91 50       	subi	r25, 0x01	; 1
     6d0:	e0 40       	sbci	r30, 0x00	; 0
     6d2:	f0 40       	sbci	r31, 0x00	; 0
     6d4:	e1 f7       	brne	.-8      	; 0x6ce <main+0x26e>
     6d6:	00 c0       	rjmp	.+0      	; 0x6d8 <main+0x278>
     6d8:	00 00       	nop
     6da:	18 50       	subi	r17, 0x08	; 8
			_delay_ms(500);
			clear();
		}
		else if((g_unAdcValue>500)&&(g_unAdcValue<=600))
		{
			for(int i = 7; i >= 0; i--)
     6dc:	18 3f       	cpi	r17, 0xF8	; 248
     6de:	b1 f6       	brne	.-84     	; 0x68c <main+0x22c>
     6e0:	2f ef       	ldi	r18, 0xFF	; 255
     6e2:	89 e6       	ldi	r24, 0x69	; 105
     6e4:	98 e1       	ldi	r25, 0x18	; 24
     6e6:	21 50       	subi	r18, 0x01	; 1
     6e8:	80 40       	sbci	r24, 0x00	; 0
     6ea:	90 40       	sbci	r25, 0x00	; 0
     6ec:	e1 f7       	brne	.-8      	; 0x6e6 <main+0x286>
     6ee:	00 c0       	rjmp	.+0      	; 0x6f0 <main+0x290>
     6f0:	00 00       	nop
				setColor_RGB(3 + line, 0x1DDB16);			// Green
				show();
				_delay_ms(100);
			}
			_delay_ms(500);
			clear();
     6f2:	36 d2       	rcall	.+1132   	; 0xb60 <clear>
     6f4:	d6 ce       	rjmp	.-596    	; 0x4a2 <main+0x42>
		}
		else if((g_unAdcValue>300)&&(g_unAdcValue<=500))
     6f6:	9c 01       	movw	r18, r24
     6f8:	2d 52       	subi	r18, 0x2D	; 45
     6fa:	31 40       	sbci	r19, 0x01	; 1
     6fc:	28 3c       	cpi	r18, 0xC8	; 200
     6fe:	31 05       	cpc	r19, r1
     700:	78 f5       	brcc	.+94     	; 0x760 <main+0x300>
     702:	c8 e3       	ldi	r28, 0x38	; 56
		{
		
			for(int i = 7; i >= 0; i--)
			{
				line = i * 8;
				setColor_RGB(0 + line, 0xFF0000);			// RED
     704:	0c 2f       	mov	r16, r28
     706:	10 e0       	ldi	r17, 0x00	; 0
     708:	40 e0       	ldi	r20, 0x00	; 0
     70a:	50 e0       	ldi	r21, 0x00	; 0
     70c:	6f ef       	ldi	r22, 0xFF	; 255
     70e:	70 e0       	ldi	r23, 0x00	; 0
     710:	c8 01       	movw	r24, r16
     712:	e3 d0       	rcall	.+454    	; 0x8da <setColor_RGB>
				setColor_RGB(1 + line, 0xFF5E00);			// Orange
     714:	40 e0       	ldi	r20, 0x00	; 0
     716:	5e e5       	ldi	r21, 0x5E	; 94
     718:	6f ef       	ldi	r22, 0xFF	; 255
     71a:	70 e0       	ldi	r23, 0x00	; 0
     71c:	c8 01       	movw	r24, r16
     71e:	01 96       	adiw	r24, 0x01	; 1
     720:	dc d0       	rcall	.+440    	; 0x8da <setColor_RGB>
				setColor_RGB(2 + line, 0xFFE400);			// Yellow
     722:	40 e0       	ldi	r20, 0x00	; 0
     724:	54 ee       	ldi	r21, 0xE4	; 228
     726:	6f ef       	ldi	r22, 0xFF	; 255
     728:	70 e0       	ldi	r23, 0x00	; 0
     72a:	c8 01       	movw	r24, r16
     72c:	02 96       	adiw	r24, 0x02	; 2
     72e:	d5 d0       	rcall	.+426    	; 0x8da <setColor_RGB>
				show();
     730:	42 d1       	rcall	.+644    	; 0x9b6 <show>
     732:	ef ef       	ldi	r30, 0xFF	; 255
     734:	f1 ee       	ldi	r31, 0xE1	; 225
     736:	24 e0       	ldi	r18, 0x04	; 4
     738:	e1 50       	subi	r30, 0x01	; 1
     73a:	f0 40       	sbci	r31, 0x00	; 0
     73c:	20 40       	sbci	r18, 0x00	; 0
     73e:	e1 f7       	brne	.-8      	; 0x738 <main+0x2d8>
     740:	00 c0       	rjmp	.+0      	; 0x742 <main+0x2e2>
     742:	00 00       	nop
     744:	c8 50       	subi	r28, 0x08	; 8
			clear();
		}
		else if((g_unAdcValue>300)&&(g_unAdcValue<=500))
		{
		
			for(int i = 7; i >= 0; i--)
     746:	c8 3f       	cpi	r28, 0xF8	; 248
     748:	e9 f6       	brne	.-70     	; 0x704 <main+0x2a4>
     74a:	8f ef       	ldi	r24, 0xFF	; 255
     74c:	99 e6       	ldi	r25, 0x69	; 105
     74e:	e8 e1       	ldi	r30, 0x18	; 24
     750:	81 50       	subi	r24, 0x01	; 1
     752:	90 40       	sbci	r25, 0x00	; 0
     754:	e0 40       	sbci	r30, 0x00	; 0
     756:	e1 f7       	brne	.-8      	; 0x750 <main+0x2f0>
     758:	00 c0       	rjmp	.+0      	; 0x75a <main+0x2fa>
     75a:	00 00       	nop
				setColor_RGB(2 + line, 0xFFE400);			// Yellow
				show();
				_delay_ms(100);
			}
			_delay_ms(500);
			clear();
     75c:	01 d2       	rcall	.+1026   	; 0xb60 <clear>
     75e:	a1 ce       	rjmp	.-702    	; 0x4a2 <main+0x42>
		}
		else if((g_unAdcValue>100)&&(g_unAdcValue<=300))
     760:	9c 01       	movw	r18, r24
     762:	25 56       	subi	r18, 0x65	; 101
     764:	31 09       	sbc	r19, r1
     766:	28 3c       	cpi	r18, 0xC8	; 200
     768:	31 05       	cpc	r19, r1
     76a:	40 f5       	brcc	.+80     	; 0x7bc <main+0x35c>
     76c:	c8 e3       	ldi	r28, 0x38	; 56
		{
		
			for(int i = 7; i >= 0; i--)
			{
				line = i * 8;
				setColor_RGB(0 + line, 0xFF0000);			// RED
     76e:	0c 2f       	mov	r16, r28
     770:	10 e0       	ldi	r17, 0x00	; 0
     772:	40 e0       	ldi	r20, 0x00	; 0
     774:	50 e0       	ldi	r21, 0x00	; 0
     776:	6f ef       	ldi	r22, 0xFF	; 255
     778:	70 e0       	ldi	r23, 0x00	; 0
     77a:	c8 01       	movw	r24, r16
     77c:	ae d0       	rcall	.+348    	; 0x8da <setColor_RGB>
				setColor_RGB(1 + line, 0xFF5E00);			// Orange
     77e:	40 e0       	ldi	r20, 0x00	; 0
     780:	5e e5       	ldi	r21, 0x5E	; 94
     782:	6f ef       	ldi	r22, 0xFF	; 255
     784:	70 e0       	ldi	r23, 0x00	; 0
     786:	c8 01       	movw	r24, r16
     788:	01 96       	adiw	r24, 0x01	; 1
     78a:	a7 d0       	rcall	.+334    	; 0x8da <setColor_RGB>
				show();
     78c:	14 d1       	rcall	.+552    	; 0x9b6 <show>
     78e:	ff ef       	ldi	r31, 0xFF	; 255
     790:	21 ee       	ldi	r18, 0xE1	; 225
     792:	84 e0       	ldi	r24, 0x04	; 4
     794:	f1 50       	subi	r31, 0x01	; 1
     796:	20 40       	sbci	r18, 0x00	; 0
     798:	80 40       	sbci	r24, 0x00	; 0
     79a:	e1 f7       	brne	.-8      	; 0x794 <main+0x334>
     79c:	00 c0       	rjmp	.+0      	; 0x79e <main+0x33e>
     79e:	00 00       	nop
     7a0:	c8 50       	subi	r28, 0x08	; 8
			clear();
		}
		else if((g_unAdcValue>100)&&(g_unAdcValue<=300))
		{
		
			for(int i = 7; i >= 0; i--)
     7a2:	c8 3f       	cpi	r28, 0xF8	; 248
     7a4:	21 f7       	brne	.-56     	; 0x76e <main+0x30e>
     7a6:	9f ef       	ldi	r25, 0xFF	; 255
     7a8:	e9 e6       	ldi	r30, 0x69	; 105
     7aa:	f8 e1       	ldi	r31, 0x18	; 24
     7ac:	91 50       	subi	r25, 0x01	; 1
     7ae:	e0 40       	sbci	r30, 0x00	; 0
     7b0:	f0 40       	sbci	r31, 0x00	; 0
     7b2:	e1 f7       	brne	.-8      	; 0x7ac <main+0x34c>
     7b4:	00 c0       	rjmp	.+0      	; 0x7b6 <main+0x356>
     7b6:	00 00       	nop
				setColor_RGB(1 + line, 0xFF5E00);			// Orange
				show();
				_delay_ms(100);
			}
			_delay_ms(500);
			clear();
     7b8:	d3 d1       	rcall	.+934    	; 0xb60 <clear>
     7ba:	73 ce       	rjmp	.-794    	; 0x4a2 <main+0x42>
		}
		else if((g_unAdcValue>30)&&(g_unAdcValue<=100))
     7bc:	9c 01       	movw	r18, r24
     7be:	2f 51       	subi	r18, 0x1F	; 31
     7c0:	31 09       	sbc	r19, r1
     7c2:	26 34       	cpi	r18, 0x46	; 70
     7c4:	31 05       	cpc	r19, r1
     7c6:	00 f5       	brcc	.+64     	; 0x808 <main+0x3a8>
     7c8:	c8 e3       	ldi	r28, 0x38	; 56
			{
			
				for(int i = 7; i >= 0; i--)
				{
					line = i * 8;
					setColor_RGB(0 + line, 0xFF0000);			// RED
     7ca:	40 e0       	ldi	r20, 0x00	; 0
     7cc:	50 e0       	ldi	r21, 0x00	; 0
     7ce:	6f ef       	ldi	r22, 0xFF	; 255
     7d0:	70 e0       	ldi	r23, 0x00	; 0
     7d2:	8c 2f       	mov	r24, r28
     7d4:	90 e0       	ldi	r25, 0x00	; 0
     7d6:	81 d0       	rcall	.+258    	; 0x8da <setColor_RGB>
					show();
     7d8:	ee d0       	rcall	.+476    	; 0x9b6 <show>
     7da:	2f ef       	ldi	r18, 0xFF	; 255
     7dc:	81 ee       	ldi	r24, 0xE1	; 225
     7de:	94 e0       	ldi	r25, 0x04	; 4
     7e0:	21 50       	subi	r18, 0x01	; 1
     7e2:	80 40       	sbci	r24, 0x00	; 0
     7e4:	90 40       	sbci	r25, 0x00	; 0
     7e6:	e1 f7       	brne	.-8      	; 0x7e0 <main+0x380>
     7e8:	00 c0       	rjmp	.+0      	; 0x7ea <main+0x38a>
     7ea:	00 00       	nop
     7ec:	c8 50       	subi	r28, 0x08	; 8
			clear();
		}
		else if((g_unAdcValue>30)&&(g_unAdcValue<=100))
			{
			
				for(int i = 7; i >= 0; i--)
     7ee:	c8 3f       	cpi	r28, 0xF8	; 248
     7f0:	61 f7       	brne	.-40     	; 0x7ca <main+0x36a>
     7f2:	ef ef       	ldi	r30, 0xFF	; 255
     7f4:	f9 e6       	ldi	r31, 0x69	; 105
     7f6:	28 e1       	ldi	r18, 0x18	; 24
     7f8:	e1 50       	subi	r30, 0x01	; 1
     7fa:	f0 40       	sbci	r31, 0x00	; 0
     7fc:	20 40       	sbci	r18, 0x00	; 0
     7fe:	e1 f7       	brne	.-8      	; 0x7f8 <main+0x398>
     800:	00 c0       	rjmp	.+0      	; 0x802 <main+0x3a2>
     802:	00 00       	nop
					setColor_RGB(0 + line, 0xFF0000);			// RED
					show();
					_delay_ms(100);
				}
				_delay_ms(500);
				clear();
     804:	ad d1       	rcall	.+858    	; 0xb60 <clear>
     806:	4d ce       	rjmp	.-870    	; 0x4a2 <main+0x42>
			}
		else if((g_unAdcValue>=0)&&(g_unAdcValue<=30))
     808:	4f 97       	sbiw	r24, 0x1f	; 31
     80a:	10 f4       	brcc	.+4      	; 0x810 <main+0x3b0>
		{
			clear();
     80c:	a9 d1       	rcall	.+850    	; 0xb60 <clear>
     80e:	49 ce       	rjmp	.-878    	; 0x4a2 <main+0x42>
     810:	18 e3       	ldi	r17, 0x38	; 56
		else
		{
			for(int i = 7; i >= 0; i--)
			{
				line = i * 8;
				setColor_RGB(0 + line, 0xFF0000);			// RED
     812:	c1 2f       	mov	r28, r17
     814:	d0 e0       	ldi	r29, 0x00	; 0
     816:	40 e0       	ldi	r20, 0x00	; 0
     818:	50 e0       	ldi	r21, 0x00	; 0
     81a:	6f ef       	ldi	r22, 0xFF	; 255
     81c:	70 e0       	ldi	r23, 0x00	; 0
     81e:	ce 01       	movw	r24, r28
     820:	5c d0       	rcall	.+184    	; 0x8da <setColor_RGB>
				setColor_RGB(1 + line, 0xFF5E00);			// Orange
     822:	40 e0       	ldi	r20, 0x00	; 0
     824:	5e e5       	ldi	r21, 0x5E	; 94
     826:	6f ef       	ldi	r22, 0xFF	; 255
     828:	70 e0       	ldi	r23, 0x00	; 0
     82a:	ce 01       	movw	r24, r28
     82c:	01 96       	adiw	r24, 0x01	; 1
     82e:	55 d0       	rcall	.+170    	; 0x8da <setColor_RGB>
				setColor_RGB(2 + line, 0xFFE400);			// Yellow
     830:	40 e0       	ldi	r20, 0x00	; 0
     832:	54 ee       	ldi	r21, 0xE4	; 228
     834:	6f ef       	ldi	r22, 0xFF	; 255
     836:	70 e0       	ldi	r23, 0x00	; 0
     838:	ce 01       	movw	r24, r28
     83a:	02 96       	adiw	r24, 0x02	; 2
     83c:	4e d0       	rcall	.+156    	; 0x8da <setColor_RGB>
				setColor_RGB(3 + line, 0x1DDB16);			// Green
     83e:	46 e1       	ldi	r20, 0x16	; 22
     840:	5b ed       	ldi	r21, 0xDB	; 219
     842:	6d e1       	ldi	r22, 0x1D	; 29
     844:	70 e0       	ldi	r23, 0x00	; 0
     846:	ce 01       	movw	r24, r28
     848:	03 96       	adiw	r24, 0x03	; 3
     84a:	47 d0       	rcall	.+142    	; 0x8da <setColor_RGB>
				setColor_RGB(4 + line, 0x0000FF);			// Blue
     84c:	4f ef       	ldi	r20, 0xFF	; 255
     84e:	50 e0       	ldi	r21, 0x00	; 0
     850:	60 e0       	ldi	r22, 0x00	; 0
     852:	70 e0       	ldi	r23, 0x00	; 0
     854:	ce 01       	movw	r24, r28
     856:	04 96       	adiw	r24, 0x04	; 4
     858:	40 d0       	rcall	.+128    	; 0x8da <setColor_RGB>
				setColor_RGB(5 + line, 0x0100FF);			// Dark Blue
     85a:	4f ef       	ldi	r20, 0xFF	; 255
     85c:	50 e0       	ldi	r21, 0x00	; 0
     85e:	61 e0       	ldi	r22, 0x01	; 1
     860:	70 e0       	ldi	r23, 0x00	; 0
     862:	ce 01       	movw	r24, r28
     864:	05 96       	adiw	r24, 0x05	; 5
     866:	39 d0       	rcall	.+114    	; 0x8da <setColor_RGB>
				setColor_RGB(6 + line, 0x3F0099);			// Purple
     868:	49 e9       	ldi	r20, 0x99	; 153
     86a:	50 e0       	ldi	r21, 0x00	; 0
     86c:	6f e3       	ldi	r22, 0x3F	; 63
     86e:	70 e0       	ldi	r23, 0x00	; 0
     870:	ce 01       	movw	r24, r28
     872:	06 96       	adiw	r24, 0x06	; 6
     874:	32 d0       	rcall	.+100    	; 0x8da <setColor_RGB>
				setColor_RGB(7 + line, 0xFF00DD);			// Pink
     876:	4d ed       	ldi	r20, 0xDD	; 221
     878:	50 e0       	ldi	r21, 0x00	; 0
     87a:	6f ef       	ldi	r22, 0xFF	; 255
     87c:	70 e0       	ldi	r23, 0x00	; 0
     87e:	ce 01       	movw	r24, r28
     880:	07 96       	adiw	r24, 0x07	; 7
     882:	2b d0       	rcall	.+86     	; 0x8da <setColor_RGB>
				show();
     884:	98 d0       	rcall	.+304    	; 0x9b6 <show>
     886:	8f ef       	ldi	r24, 0xFF	; 255
     888:	91 ee       	ldi	r25, 0xE1	; 225
     88a:	e4 e0       	ldi	r30, 0x04	; 4
     88c:	81 50       	subi	r24, 0x01	; 1
     88e:	90 40       	sbci	r25, 0x00	; 0
     890:	e0 40       	sbci	r30, 0x00	; 0
     892:	e1 f7       	brne	.-8      	; 0x88c <main+0x42c>
     894:	00 c0       	rjmp	.+0      	; 0x896 <main+0x436>
     896:	00 00       	nop
     898:	18 50       	subi	r17, 0x08	; 8
		{
			clear();
		}	
		else
		{
			for(int i = 7; i >= 0; i--)
     89a:	18 3f       	cpi	r17, 0xF8	; 248
     89c:	09 f0       	breq	.+2      	; 0x8a0 <main+0x440>
     89e:	b9 cf       	rjmp	.-142    	; 0x812 <main+0x3b2>
     8a0:	ff ef       	ldi	r31, 0xFF	; 255
     8a2:	29 e6       	ldi	r18, 0x69	; 105
     8a4:	88 e1       	ldi	r24, 0x18	; 24
     8a6:	f1 50       	subi	r31, 0x01	; 1
     8a8:	20 40       	sbci	r18, 0x00	; 0
     8aa:	80 40       	sbci	r24, 0x00	; 0
     8ac:	e1 f7       	brne	.-8      	; 0x8a6 <main+0x446>
     8ae:	00 c0       	rjmp	.+0      	; 0x8b0 <main+0x450>
     8b0:	00 00       	nop
				setColor_RGB(7 + line, 0xFF00DD);			// Pink
				show();
				_delay_ms(100);
			}
			_delay_ms(500);
			clear();
     8b2:	56 d1       	rcall	.+684    	; 0xb60 <clear>
     8b4:	f6 cd       	rjmp	.-1044   	; 0x4a2 <main+0x42>

000008b6 <setPin>:


void cell_clear(uint16_t nCell)
{
	setColor(nCell, 0, 0, 0);
	show();
     8b6:	e8 2f       	mov	r30, r24
     8b8:	f0 e0       	ldi	r31, 0x00	; 0
     8ba:	df 01       	movw	r26, r30
     8bc:	8e 91       	ld	r24, -X
     8be:	21 e0       	ldi	r18, 0x01	; 1
     8c0:	30 e0       	ldi	r19, 0x00	; 0
     8c2:	02 c0       	rjmp	.+4      	; 0x8c8 <setPin+0x12>
     8c4:	22 0f       	add	r18, r18
     8c6:	33 1f       	adc	r19, r19
     8c8:	6a 95       	dec	r22
     8ca:	e2 f7       	brpl	.-8      	; 0x8c4 <setPin+0xe>
     8cc:	82 2b       	or	r24, r18
     8ce:	8c 93       	st	X, r24
     8d0:	80 81       	ld	r24, Z
     8d2:	20 95       	com	r18
     8d4:	28 23       	and	r18, r24
     8d6:	20 83       	st	Z, r18
     8d8:	08 95       	ret

000008da <setColor_RGB>:
     8da:	8f 92       	push	r8
     8dc:	9f 92       	push	r9
     8de:	af 92       	push	r10
     8e0:	bf 92       	push	r11
     8e2:	cf 92       	push	r12
     8e4:	df 92       	push	r13
     8e6:	ef 92       	push	r14
     8e8:	ff 92       	push	r15
     8ea:	20 91 25 03 	lds	r18, 0x0325	; 0x800325 <nCells>
     8ee:	30 91 26 03 	lds	r19, 0x0326	; 0x800326 <nCells+0x1>
     8f2:	82 17       	cp	r24, r18
     8f4:	93 07       	cpc	r25, r19
     8f6:	08 f0       	brcs	.+2      	; 0x8fa <setColor_RGB+0x20>
     8f8:	55 c0       	rjmp	.+170    	; 0x9a4 <setColor_RGB+0xca>
     8fa:	6b 01       	movw	r12, r22
     8fc:	ee 24       	eor	r14, r14
     8fe:	ff 24       	eor	r15, r15
     900:	ac 2d       	mov	r26, r12
     902:	85 2e       	mov	r8, r21
     904:	96 2e       	mov	r9, r22
     906:	a7 2e       	mov	r10, r23
     908:	bb 24       	eor	r11, r11
     90a:	b8 2d       	mov	r27, r8
     90c:	24 2f       	mov	r18, r20
     90e:	30 91 24 01 	lds	r19, 0x0124	; 0x800124 <brightness>
     912:	3f 3f       	cpi	r19, 0xFF	; 255
     914:	c9 f1       	breq	.+114    	; 0x988 <setColor_RGB+0xae>
     916:	20 91 24 01 	lds	r18, 0x0124	; 0x800124 <brightness>
     91a:	22 30       	cpi	r18, 0x02	; 2
     91c:	80 f1       	brcs	.+96     	; 0x97e <setColor_RGB+0xa4>
     91e:	20 91 24 01 	lds	r18, 0x0124	; 0x800124 <brightness>
     922:	30 e0       	ldi	r19, 0x00	; 0
     924:	2f 5f       	subi	r18, 0xFF	; 255
     926:	3f 4f       	sbci	r19, 0xFF	; 255
     928:	a8 2d       	mov	r26, r8
     92a:	a1 60       	ori	r26, 0x01	; 1
     92c:	a2 9f       	mul	r26, r18
     92e:	f0 01       	movw	r30, r0
     930:	a3 9f       	mul	r26, r19
     932:	f0 0d       	add	r31, r0
     934:	11 24       	eor	r1, r1
     936:	e1 38       	cpi	r30, 0x81	; 129
     938:	f1 05       	cpc	r31, r1
     93a:	20 f0       	brcs	.+8      	; 0x944 <setColor_RGB+0x6a>
     93c:	e0 58       	subi	r30, 0x80	; 128
     93e:	f1 09       	sbc	r31, r1
     940:	bf 2f       	mov	r27, r31
     942:	01 c0       	rjmp	.+2      	; 0x946 <setColor_RGB+0x6c>
     944:	b0 e0       	ldi	r27, 0x00	; 0
     946:	ac 2d       	mov	r26, r12
     948:	a1 60       	ori	r26, 0x01	; 1
     94a:	a2 9f       	mul	r26, r18
     94c:	f0 01       	movw	r30, r0
     94e:	a3 9f       	mul	r26, r19
     950:	f0 0d       	add	r31, r0
     952:	11 24       	eor	r1, r1
     954:	e1 38       	cpi	r30, 0x81	; 129
     956:	f1 05       	cpc	r31, r1
     958:	20 f0       	brcs	.+8      	; 0x962 <setColor_RGB+0x88>
     95a:	e0 58       	subi	r30, 0x80	; 128
     95c:	f1 09       	sbc	r31, r1
     95e:	af 2f       	mov	r26, r31
     960:	01 c0       	rjmp	.+2      	; 0x964 <setColor_RGB+0x8a>
     962:	a0 e0       	ldi	r26, 0x00	; 0
     964:	41 60       	ori	r20, 0x01	; 1
     966:	42 9f       	mul	r20, r18
     968:	b0 01       	movw	r22, r0
     96a:	43 9f       	mul	r20, r19
     96c:	70 0d       	add	r23, r0
     96e:	11 24       	eor	r1, r1
     970:	61 38       	cpi	r22, 0x81	; 129
     972:	71 05       	cpc	r23, r1
     974:	40 f0       	brcs	.+16     	; 0x986 <setColor_RGB+0xac>
     976:	60 58       	subi	r22, 0x80	; 128
     978:	71 09       	sbc	r23, r1
     97a:	27 2f       	mov	r18, r23
     97c:	05 c0       	rjmp	.+10     	; 0x988 <setColor_RGB+0xae>
     97e:	20 e0       	ldi	r18, 0x00	; 0
     980:	b0 e0       	ldi	r27, 0x00	; 0
     982:	a0 e0       	ldi	r26, 0x00	; 0
     984:	01 c0       	rjmp	.+2      	; 0x988 <setColor_RGB+0xae>
     986:	20 e0       	ldi	r18, 0x00	; 0
     988:	fc 01       	movw	r30, r24
     98a:	ee 0f       	add	r30, r30
     98c:	ff 1f       	adc	r31, r31
     98e:	8e 0f       	add	r24, r30
     990:	9f 1f       	adc	r25, r31
     992:	e0 91 29 03 	lds	r30, 0x0329	; 0x800329 <cells>
     996:	f0 91 2a 03 	lds	r31, 0x032A	; 0x80032a <cells+0x1>
     99a:	e8 0f       	add	r30, r24
     99c:	f9 1f       	adc	r31, r25
     99e:	b0 83       	st	Z, r27
     9a0:	a1 83       	std	Z+1, r26	; 0x01
     9a2:	22 83       	std	Z+2, r18	; 0x02
     9a4:	ff 90       	pop	r15
     9a6:	ef 90       	pop	r14
     9a8:	df 90       	pop	r13
     9aa:	cf 90       	pop	r12
     9ac:	bf 90       	pop	r11
     9ae:	af 90       	pop	r10
     9b0:	9f 90       	pop	r9
     9b2:	8f 90       	pop	r8
     9b4:	08 95       	ret

000009b6 <show>:
     9b6:	cf 93       	push	r28
     9b8:	df 93       	push	r29
     9ba:	cd b7       	in	r28, 0x3d	; 61
     9bc:	de b7       	in	r29, 0x3e	; 62
     9be:	27 97       	sbiw	r28, 0x07	; 7
     9c0:	0f b6       	in	r0, 0x3f	; 63
     9c2:	f8 94       	cli
     9c4:	de bf       	out	0x3e, r29	; 62
     9c6:	0f be       	out	0x3f, r0	; 63
     9c8:	cd bf       	out	0x3d, r28	; 61
     9ca:	87 ec       	ldi	r24, 0xC7	; 199
     9cc:	90 e0       	ldi	r25, 0x00	; 0
     9ce:	01 97       	sbiw	r24, 0x01	; 1
     9d0:	f1 f7       	brne	.-4      	; 0x9ce <show+0x18>
     9d2:	00 c0       	rjmp	.+0      	; 0x9d4 <show+0x1e>
     9d4:	00 00       	nop
     9d6:	f8 94       	cli
     9d8:	80 91 23 03 	lds	r24, 0x0323	; 0x800323 <nBytes>
     9dc:	90 91 24 03 	lds	r25, 0x0324	; 0x800324 <nBytes+0x1>
     9e0:	9a 83       	std	Y+2, r25	; 0x02
     9e2:	89 83       	std	Y+1, r24	; 0x01
     9e4:	e0 91 29 03 	lds	r30, 0x0329	; 0x800329 <cells>
     9e8:	f0 91 2a 03 	lds	r31, 0x032A	; 0x80032a <cells+0x1>
     9ec:	df 01       	movw	r26, r30
     9ee:	11 96       	adiw	r26, 0x01	; 1
     9f0:	80 81       	ld	r24, Z
     9f2:	8b 83       	std	Y+3, r24	; 0x03
     9f4:	e0 91 27 03 	lds	r30, 0x0327	; 0x800327 <port>
     9f8:	f0 91 28 03 	lds	r31, 0x0328	; 0x800328 <port+0x1>
     9fc:	90 81       	ld	r25, Z
     9fe:	80 91 2b 03 	lds	r24, 0x032B	; 0x80032b <maskPin>
     a02:	89 2b       	or	r24, r25
     a04:	8e 83       	std	Y+6, r24	; 0x06
     a06:	90 81       	ld	r25, Z
     a08:	80 91 2b 03 	lds	r24, 0x032B	; 0x80032b <maskPin>
     a0c:	80 95       	com	r24
     a0e:	89 23       	and	r24, r25
     a10:	8f 83       	std	Y+7, r24	; 0x07
     a12:	8f 81       	ldd	r24, Y+7	; 0x07
     a14:	8c 83       	std	Y+4, r24	; 0x04
     a16:	88 e0       	ldi	r24, 0x08	; 8
     a18:	8d 83       	std	Y+5, r24	; 0x05
     a1a:	5e 81       	ldd	r21, Y+6	; 0x06
     a1c:	6f 81       	ldd	r22, Y+7	; 0x07
     a1e:	4b 81       	ldd	r20, Y+3	; 0x03
     a20:	3d 81       	ldd	r19, Y+5	; 0x05
     a22:	2c 81       	ldd	r18, Y+4	; 0x04
     a24:	89 81       	ldd	r24, Y+1	; 0x01
     a26:	9a 81       	ldd	r25, Y+2	; 0x02

00000a28 <run>:
     a28:	50 83       	st	Z, r21
     a2a:	47 fd       	sbrc	r20, 7
     a2c:	25 2f       	mov	r18, r21
     a2e:	20 83       	st	Z, r18
     a30:	26 2f       	mov	r18, r22
     a32:	3a 95       	dec	r19
     a34:	39 f0       	breq	.+14     	; 0xa44 <nextByte>
     a36:	44 0f       	add	r20, r20
     a38:	00 c0       	rjmp	.+0      	; 0xa3a <run+0x12>
     a3a:	00 00       	nop
     a3c:	60 83       	st	Z, r22
     a3e:	00 c0       	rjmp	.+0      	; 0xa40 <run+0x18>
     a40:	00 00       	nop
     a42:	f2 cf       	rjmp	.-28     	; 0xa28 <run>

00000a44 <nextByte>:
     a44:	4d 91       	ld	r20, X+
     a46:	60 83       	st	Z, r22
     a48:	38 e0       	ldi	r19, 0x08	; 8
     a4a:	00 00       	nop
     a4c:	01 97       	sbiw	r24, 0x01	; 1
     a4e:	61 f7       	brne	.-40     	; 0xa28 <run>
     a50:	f0 93 28 03 	sts	0x0328, r31	; 0x800328 <port+0x1>
     a54:	e0 93 27 03 	sts	0x0327, r30	; 0x800327 <port>
     a58:	4b 83       	std	Y+3, r20	; 0x03
     a5a:	3d 83       	std	Y+5, r19	; 0x05
     a5c:	2c 83       	std	Y+4, r18	; 0x04
     a5e:	9a 83       	std	Y+2, r25	; 0x02
     a60:	89 83       	std	Y+1, r24	; 0x01
     a62:	78 94       	sei
     a64:	87 ec       	ldi	r24, 0xC7	; 199
     a66:	90 e0       	ldi	r25, 0x00	; 0
     a68:	01 97       	sbiw	r24, 0x01	; 1
     a6a:	f1 f7       	brne	.-4      	; 0xa68 <nextByte+0x24>
     a6c:	00 c0       	rjmp	.+0      	; 0xa6e <nextByte+0x2a>
     a6e:	00 00       	nop
     a70:	27 96       	adiw	r28, 0x07	; 7
     a72:	0f b6       	in	r0, 0x3f	; 63
     a74:	f8 94       	cli
     a76:	de bf       	out	0x3e, r29	; 62
     a78:	0f be       	out	0x3f, r0	; 63
     a7a:	cd bf       	out	0x3d, r28	; 61
     a7c:	df 91       	pop	r29
     a7e:	cf 91       	pop	r28
     a80:	08 95       	ret

00000a82 <NS_Rainbow_init>:
     a82:	ff 92       	push	r15
     a84:	0f 93       	push	r16
     a86:	1f 93       	push	r17
     a88:	cf 93       	push	r28
     a8a:	df 93       	push	r29
     a8c:	1f 92       	push	r1
     a8e:	cd b7       	in	r28, 0x3d	; 61
     a90:	de b7       	in	r29, 0x3e	; 62
     a92:	8c 01       	movw	r16, r24
     a94:	69 83       	std	Y+1, r22	; 0x01
     a96:	f4 2e       	mov	r15, r20
     a98:	89 81       	ldd	r24, Y+1	; 0x01
     a9a:	64 2f       	mov	r22, r20
     a9c:	0c df       	rcall	.-488    	; 0x8b6 <setPin>
     a9e:	89 81       	ldd	r24, Y+1	; 0x01
     aa0:	90 e0       	ldi	r25, 0x00	; 0
     aa2:	90 93 28 03 	sts	0x0328, r25	; 0x800328 <port+0x1>
     aa6:	80 93 27 03 	sts	0x0327, r24	; 0x800327 <port>
     aaa:	81 e0       	ldi	r24, 0x01	; 1
     aac:	90 e0       	ldi	r25, 0x00	; 0
     aae:	02 c0       	rjmp	.+4      	; 0xab4 <NS_Rainbow_init+0x32>
     ab0:	88 0f       	add	r24, r24
     ab2:	99 1f       	adc	r25, r25
     ab4:	fa 94       	dec	r15
     ab6:	e2 f7       	brpl	.-8      	; 0xab0 <NS_Rainbow_init+0x2e>
     ab8:	80 93 2b 03 	sts	0x032B, r24	; 0x80032b <maskPin>
     abc:	10 93 26 03 	sts	0x0326, r17	; 0x800326 <nCells+0x1>
     ac0:	00 93 25 03 	sts	0x0325, r16	; 0x800325 <nCells>
     ac4:	80 91 25 01 	lds	r24, 0x0125	; 0x800125 <maxLEDBytes>
     ac8:	90 91 26 01 	lds	r25, 0x0126	; 0x800126 <maxLEDBytes+0x1>
     acc:	90 93 24 03 	sts	0x0324, r25	; 0x800324 <nBytes+0x1>
     ad0:	80 93 23 03 	sts	0x0323, r24	; 0x800323 <nBytes>
     ad4:	8f ef       	ldi	r24, 0xFF	; 255
     ad6:	80 93 24 01 	sts	0x0124, r24	; 0x800124 <brightness>
     ada:	80 91 23 03 	lds	r24, 0x0323	; 0x800323 <nBytes>
     ade:	90 91 24 03 	lds	r25, 0x0324	; 0x800324 <nBytes+0x1>
     ae2:	65 d1       	rcall	.+714    	; 0xdae <malloc>
     ae4:	90 93 2a 03 	sts	0x032A, r25	; 0x80032a <cells+0x1>
     ae8:	80 93 29 03 	sts	0x0329, r24	; 0x800329 <cells>
     aec:	00 97       	sbiw	r24, 0x00	; 0
     aee:	39 f0       	breq	.+14     	; 0xafe <NS_Rainbow_init+0x7c>
     af0:	40 91 23 03 	lds	r20, 0x0323	; 0x800323 <nBytes>
     af4:	50 91 24 03 	lds	r21, 0x0324	; 0x800324 <nBytes+0x1>
     af8:	60 e0       	ldi	r22, 0x00	; 0
     afa:	70 e0       	ldi	r23, 0x00	; 0
     afc:	91 d2       	rcall	.+1314   	; 0x1020 <memset>
     afe:	5b df       	rcall	.-330    	; 0x9b6 <show>
     b00:	80 91 29 03 	lds	r24, 0x0329	; 0x800329 <cells>
     b04:	90 91 2a 03 	lds	r25, 0x032A	; 0x80032a <cells+0x1>
     b08:	e7 d1       	rcall	.+974    	; 0xed8 <free>
     b0a:	2f ef       	ldi	r18, 0xFF	; 255
     b0c:	80 e7       	ldi	r24, 0x70	; 112
     b0e:	92 e0       	ldi	r25, 0x02	; 2
     b10:	21 50       	subi	r18, 0x01	; 1
     b12:	80 40       	sbci	r24, 0x00	; 0
     b14:	90 40       	sbci	r25, 0x00	; 0
     b16:	e1 f7       	brne	.-8      	; 0xb10 <NS_Rainbow_init+0x8e>
     b18:	00 c0       	rjmp	.+0      	; 0xb1a <NS_Rainbow_init+0x98>
     b1a:	00 00       	nop
     b1c:	c8 01       	movw	r24, r16
     b1e:	88 0f       	add	r24, r24
     b20:	99 1f       	adc	r25, r25
     b22:	08 0f       	add	r16, r24
     b24:	19 1f       	adc	r17, r25
     b26:	10 93 24 03 	sts	0x0324, r17	; 0x800324 <nBytes+0x1>
     b2a:	00 93 23 03 	sts	0x0323, r16	; 0x800323 <nBytes>
     b2e:	80 91 23 03 	lds	r24, 0x0323	; 0x800323 <nBytes>
     b32:	90 91 24 03 	lds	r25, 0x0324	; 0x800324 <nBytes+0x1>
     b36:	3b d1       	rcall	.+630    	; 0xdae <malloc>
     b38:	90 93 2a 03 	sts	0x032A, r25	; 0x80032a <cells+0x1>
     b3c:	80 93 29 03 	sts	0x0329, r24	; 0x800329 <cells>
     b40:	00 97       	sbiw	r24, 0x00	; 0
     b42:	39 f0       	breq	.+14     	; 0xb52 <NS_Rainbow_init+0xd0>
     b44:	40 91 23 03 	lds	r20, 0x0323	; 0x800323 <nBytes>
     b48:	50 91 24 03 	lds	r21, 0x0324	; 0x800324 <nBytes+0x1>
     b4c:	60 e0       	ldi	r22, 0x00	; 0
     b4e:	70 e0       	ldi	r23, 0x00	; 0
     b50:	67 d2       	rcall	.+1230   	; 0x1020 <memset>
     b52:	0f 90       	pop	r0
     b54:	df 91       	pop	r29
     b56:	cf 91       	pop	r28
     b58:	1f 91       	pop	r17
     b5a:	0f 91       	pop	r16
     b5c:	ff 90       	pop	r15
     b5e:	08 95       	ret

00000b60 <clear>:
     b60:	40 91 23 03 	lds	r20, 0x0323	; 0x800323 <nBytes>
     b64:	50 91 24 03 	lds	r21, 0x0324	; 0x800324 <nBytes+0x1>
     b68:	60 e0       	ldi	r22, 0x00	; 0
     b6a:	70 e0       	ldi	r23, 0x00	; 0
     b6c:	80 91 29 03 	lds	r24, 0x0329	; 0x800329 <cells>
     b70:	90 91 2a 03 	lds	r25, 0x032A	; 0x80032a <cells+0x1>
     b74:	55 d2       	rcall	.+1194   	; 0x1020 <memset>
     b76:	1f cf       	rjmp	.-450    	; 0x9b6 <show>
     b78:	08 95       	ret

00000b7a <setBrightness>:
}



void setBrightness(uint8_t b)
{
     b7a:	4f 92       	push	r4
     b7c:	5f 92       	push	r5
     b7e:	6f 92       	push	r6
     b80:	7f 92       	push	r7
     b82:	8f 92       	push	r8
     b84:	9f 92       	push	r9
     b86:	af 92       	push	r10
     b88:	bf 92       	push	r11
     b8a:	df 92       	push	r13
     b8c:	ef 92       	push	r14
     b8e:	ff 92       	push	r15
     b90:	0f 93       	push	r16
     b92:	1f 93       	push	r17
     b94:	cf 93       	push	r28
     b96:	df 93       	push	r29
     b98:	d8 2e       	mov	r13, r24
	if( b != brightness )
     b9a:	80 91 24 01 	lds	r24, 0x0124	; 0x800124 <brightness>
     b9e:	d8 16       	cp	r13, r24
     ba0:	09 f4       	brne	.+2      	; 0xba4 <setBrightness+0x2a>
     ba2:	b4 c0       	rjmp	.+360    	; 0xd0c <setBrightness+0x192>
	{
		uint8_t *ptr = cells;
     ba4:	90 91 29 03 	lds	r25, 0x0329	; 0x800329 <cells>
     ba8:	80 91 2a 03 	lds	r24, 0x032A	; 0x80032a <cells+0x1>
		uint16_t nb = b + 1, cb = brightness + 1;
     bac:	80 90 24 01 	lds	r8, 0x0124	; 0x800124 <brightness>
     bb0:	91 2c       	mov	r9, r1
     bb2:	2f ef       	ldi	r18, 0xFF	; 255
     bb4:	82 1a       	sub	r8, r18
     bb6:	92 0a       	sbc	r9, r18
		
		if (b < 1)
     bb8:	d1 10       	cpse	r13, r1
     bba:	35 c0       	rjmp	.+106    	; 0xc26 <setBrightness+0xac>
		{
			for(uint16_t i = 0; i < nBytes; i++)
     bbc:	20 91 23 03 	lds	r18, 0x0323	; 0x800323 <nBytes>
     bc0:	30 91 24 03 	lds	r19, 0x0324	; 0x800324 <nBytes+0x1>
     bc4:	23 2b       	or	r18, r19
     bc6:	09 f4       	brne	.+2      	; 0xbca <setBrightness+0x50>
     bc8:	9f c0       	rjmp	.+318    	; 0xd08 <setBrightness+0x18e>
     bca:	c9 2f       	mov	r28, r25
     bcc:	d8 2f       	mov	r29, r24
     bce:	e9 2e       	mov	r14, r25
     bd0:	f8 2e       	mov	r15, r24
     bd2:	00 e0       	ldi	r16, 0x00	; 0
     bd4:	10 e0       	ldi	r17, 0x00	; 0
			(*ptr > 0) ? (*ptr++ = (((uint32_t)(*ptr + 1) << 16) / cb - 0x80) >> 8) : (*ptr++ = 0);
     bd6:	a1 2c       	mov	r10, r1
     bd8:	b1 2c       	mov	r11, r1
     bda:	f7 01       	movw	r30, r14
     bdc:	81 91       	ld	r24, Z+
     bde:	7f 01       	movw	r14, r30
     be0:	88 23       	and	r24, r24
     be2:	a9 f0       	breq	.+42     	; 0xc0e <setBrightness+0x94>
     be4:	60 81       	ld	r22, Z
     be6:	70 e0       	ldi	r23, 0x00	; 0
     be8:	6f 5f       	subi	r22, 0xFF	; 255
     bea:	7f 4f       	sbci	r23, 0xFF	; 255
     bec:	cb 01       	movw	r24, r22
     bee:	77 0f       	add	r23, r23
     bf0:	aa 0b       	sbc	r26, r26
     bf2:	bb 0b       	sbc	r27, r27
     bf4:	77 27       	eor	r23, r23
     bf6:	66 27       	eor	r22, r22
     bf8:	a5 01       	movw	r20, r10
     bfa:	94 01       	movw	r18, r8
     bfc:	97 d0       	rcall	.+302    	; 0xd2c <__udivmodsi4>
     bfe:	da 01       	movw	r26, r20
     c00:	c9 01       	movw	r24, r18
     c02:	80 58       	subi	r24, 0x80	; 128
     c04:	91 09       	sbc	r25, r1
     c06:	a1 09       	sbc	r26, r1
     c08:	b1 09       	sbc	r27, r1
     c0a:	98 83       	st	Y, r25
     c0c:	01 c0       	rjmp	.+2      	; 0xc10 <setBrightness+0x96>
     c0e:	18 82       	st	Y, r1
		uint8_t *ptr = cells;
		uint16_t nb = b + 1, cb = brightness + 1;
		
		if (b < 1)
		{
			for(uint16_t i = 0; i < nBytes; i++)
     c10:	0f 5f       	subi	r16, 0xFF	; 255
     c12:	1f 4f       	sbci	r17, 0xFF	; 255
     c14:	80 91 23 03 	lds	r24, 0x0323	; 0x800323 <nBytes>
     c18:	90 91 24 03 	lds	r25, 0x0324	; 0x800324 <nBytes+0x1>
     c1c:	21 96       	adiw	r28, 0x01	; 1
     c1e:	08 17       	cp	r16, r24
     c20:	19 07       	cpc	r17, r25
     c22:	d8 f2       	brcs	.-74     	; 0xbda <setBrightness+0x60>
     c24:	71 c0       	rjmp	.+226    	; 0xd08 <setBrightness+0x18e>
			(*ptr > 0) ? (*ptr++ = (((uint32_t)(*ptr + 1) << 16) / cb - 0x80) >> 8) : (*ptr++ = 0);
		}
		else if (b > 0xFE)
     c26:	ff ef       	ldi	r31, 0xFF	; 255
     c28:	df 16       	cp	r13, r31
     c2a:	39 f0       	breq	.+14     	; 0xc3a <setBrightness+0xc0>
			for (uint16_t i = 0; i < nBytes; i++)
			(*ptr > 0) ? (*ptr++ = (((uint32_t)(*ptr + 1) << 16) / cb - 0x80) >> 8) : (*ptr++ = 0);
		}
		else
		{
			for (uint16_t i = 0; i < nBytes; i++)
     c2c:	20 91 23 03 	lds	r18, 0x0323	; 0x800323 <nBytes>
     c30:	30 91 24 03 	lds	r19, 0x0324	; 0x800324 <nBytes+0x1>
     c34:	23 2b       	or	r18, r19
     c36:	b1 f5       	brne	.+108    	; 0xca4 <setBrightness+0x12a>
     c38:	67 c0       	rjmp	.+206    	; 0xd08 <setBrightness+0x18e>
			for(uint16_t i = 0; i < nBytes; i++)
			(*ptr > 0) ? (*ptr++ = (((uint32_t)(*ptr + 1) << 16) / cb - 0x80) >> 8) : (*ptr++ = 0);
		}
		else if (b > 0xFE)
		{
			for (uint16_t i = 0; i < nBytes; i++)
     c3a:	20 91 23 03 	lds	r18, 0x0323	; 0x800323 <nBytes>
     c3e:	30 91 24 03 	lds	r19, 0x0324	; 0x800324 <nBytes+0x1>
     c42:	23 2b       	or	r18, r19
     c44:	09 f4       	brne	.+2      	; 0xc48 <setBrightness+0xce>
     c46:	60 c0       	rjmp	.+192    	; 0xd08 <setBrightness+0x18e>
     c48:	e9 2e       	mov	r14, r25
     c4a:	f8 2e       	mov	r15, r24
     c4c:	c9 2f       	mov	r28, r25
     c4e:	d8 2f       	mov	r29, r24
     c50:	00 e0       	ldi	r16, 0x00	; 0
     c52:	10 e0       	ldi	r17, 0x00	; 0
			(*ptr > 0) ? (*ptr++ = (((uint32_t)(*ptr + 1) << 16) / cb - 0x80) >> 8) : (*ptr++ = 0);
     c54:	a1 2c       	mov	r10, r1
     c56:	b1 2c       	mov	r11, r1
     c58:	f7 01       	movw	r30, r14
     c5a:	81 91       	ld	r24, Z+
     c5c:	7f 01       	movw	r14, r30
     c5e:	88 23       	and	r24, r24
     c60:	a9 f0       	breq	.+42     	; 0xc8c <setBrightness+0x112>
     c62:	60 81       	ld	r22, Z
     c64:	70 e0       	ldi	r23, 0x00	; 0
     c66:	6f 5f       	subi	r22, 0xFF	; 255
     c68:	7f 4f       	sbci	r23, 0xFF	; 255
     c6a:	cb 01       	movw	r24, r22
     c6c:	77 0f       	add	r23, r23
     c6e:	aa 0b       	sbc	r26, r26
     c70:	bb 0b       	sbc	r27, r27
     c72:	77 27       	eor	r23, r23
     c74:	66 27       	eor	r22, r22
     c76:	a5 01       	movw	r20, r10
     c78:	94 01       	movw	r18, r8
     c7a:	58 d0       	rcall	.+176    	; 0xd2c <__udivmodsi4>
     c7c:	da 01       	movw	r26, r20
     c7e:	c9 01       	movw	r24, r18
     c80:	80 58       	subi	r24, 0x80	; 128
     c82:	91 09       	sbc	r25, r1
     c84:	a1 09       	sbc	r26, r1
     c86:	b1 09       	sbc	r27, r1
     c88:	98 83       	st	Y, r25
     c8a:	01 c0       	rjmp	.+2      	; 0xc8e <setBrightness+0x114>
     c8c:	18 82       	st	Y, r1
			for(uint16_t i = 0; i < nBytes; i++)
			(*ptr > 0) ? (*ptr++ = (((uint32_t)(*ptr + 1) << 16) / cb - 0x80) >> 8) : (*ptr++ = 0);
		}
		else if (b > 0xFE)
		{
			for (uint16_t i = 0; i < nBytes; i++)
     c8e:	0f 5f       	subi	r16, 0xFF	; 255
     c90:	1f 4f       	sbci	r17, 0xFF	; 255
     c92:	80 91 23 03 	lds	r24, 0x0323	; 0x800323 <nBytes>
     c96:	90 91 24 03 	lds	r25, 0x0324	; 0x800324 <nBytes+0x1>
     c9a:	21 96       	adiw	r28, 0x01	; 1
     c9c:	08 17       	cp	r16, r24
     c9e:	19 07       	cpc	r17, r25
     ca0:	d8 f2       	brcs	.-74     	; 0xc58 <setBrightness+0xde>
     ca2:	32 c0       	rjmp	.+100    	; 0xd08 <setBrightness+0x18e>
void setBrightness(uint8_t b)
{
	if( b != brightness )
	{
		uint8_t *ptr = cells;
		uint16_t nb = b + 1, cb = brightness + 1;
     ca4:	4d 2c       	mov	r4, r13
     ca6:	51 2c       	mov	r5, r1
     ca8:	ff ef       	ldi	r31, 0xFF	; 255
     caa:	4f 1a       	sub	r4, r31
     cac:	5f 0a       	sbc	r5, r31
			(*ptr > 0) ? (*ptr++ = (((uint32_t)(*ptr + 1) << 16) / cb - 0x80) >> 8) : (*ptr++ = 0);
		}
		else
		{
			for (uint16_t i = 0; i < nBytes; i++)
			(*ptr > 0) ? (*ptr++ = ((uint32_t)(*ptr + 1) * (nb << 8) / cb - 0x80) >> 8) : (*ptr++ = 0);
     cae:	54 2c       	mov	r5, r4
     cb0:	44 24       	eor	r4, r4
     cb2:	61 2c       	mov	r6, r1
     cb4:	71 2c       	mov	r7, r1
     cb6:	e9 2e       	mov	r14, r25
     cb8:	f8 2e       	mov	r15, r24
     cba:	c9 2f       	mov	r28, r25
     cbc:	d8 2f       	mov	r29, r24
     cbe:	00 e0       	ldi	r16, 0x00	; 0
     cc0:	10 e0       	ldi	r17, 0x00	; 0
     cc2:	a1 2c       	mov	r10, r1
     cc4:	b1 2c       	mov	r11, r1
     cc6:	f7 01       	movw	r30, r14
     cc8:	81 91       	ld	r24, Z+
     cca:	7f 01       	movw	r14, r30
     ccc:	88 23       	and	r24, r24
     cce:	89 f0       	breq	.+34     	; 0xcf2 <setBrightness+0x178>
     cd0:	a0 81       	ld	r26, Z
     cd2:	b0 e0       	ldi	r27, 0x00	; 0
     cd4:	11 96       	adiw	r26, 0x01	; 1
     cd6:	a3 01       	movw	r20, r6
     cd8:	92 01       	movw	r18, r4
     cda:	59 d0       	rcall	.+178    	; 0xd8e <__mulshisi3>
     cdc:	a5 01       	movw	r20, r10
     cde:	94 01       	movw	r18, r8
     ce0:	25 d0       	rcall	.+74     	; 0xd2c <__udivmodsi4>
     ce2:	da 01       	movw	r26, r20
     ce4:	c9 01       	movw	r24, r18
     ce6:	80 58       	subi	r24, 0x80	; 128
     ce8:	91 09       	sbc	r25, r1
     cea:	a1 09       	sbc	r26, r1
     cec:	b1 09       	sbc	r27, r1
     cee:	98 83       	st	Y, r25
     cf0:	01 c0       	rjmp	.+2      	; 0xcf4 <setBrightness+0x17a>
     cf2:	18 82       	st	Y, r1
			for (uint16_t i = 0; i < nBytes; i++)
			(*ptr > 0) ? (*ptr++ = (((uint32_t)(*ptr + 1) << 16) / cb - 0x80) >> 8) : (*ptr++ = 0);
		}
		else
		{
			for (uint16_t i = 0; i < nBytes; i++)
     cf4:	0f 5f       	subi	r16, 0xFF	; 255
     cf6:	1f 4f       	sbci	r17, 0xFF	; 255
     cf8:	80 91 23 03 	lds	r24, 0x0323	; 0x800323 <nBytes>
     cfc:	90 91 24 03 	lds	r25, 0x0324	; 0x800324 <nBytes+0x1>
     d00:	21 96       	adiw	r28, 0x01	; 1
     d02:	08 17       	cp	r16, r24
     d04:	19 07       	cpc	r17, r25
     d06:	f8 f2       	brcs	.-66     	; 0xcc6 <setBrightness+0x14c>
			(*ptr > 0) ? (*ptr++ = ((uint32_t)(*ptr + 1) * (nb << 8) / cb - 0x80) >> 8) : (*ptr++ = 0);
		}
		brightness = b;
     d08:	d0 92 24 01 	sts	0x0124, r13	; 0x800124 <brightness>
	}
}
     d0c:	df 91       	pop	r29
     d0e:	cf 91       	pop	r28
     d10:	1f 91       	pop	r17
     d12:	0f 91       	pop	r16
     d14:	ff 90       	pop	r15
     d16:	ef 90       	pop	r14
     d18:	df 90       	pop	r13
     d1a:	bf 90       	pop	r11
     d1c:	af 90       	pop	r10
     d1e:	9f 90       	pop	r9
     d20:	8f 90       	pop	r8
     d22:	7f 90       	pop	r7
     d24:	6f 90       	pop	r6
     d26:	5f 90       	pop	r5
     d28:	4f 90       	pop	r4
     d2a:	08 95       	ret

00000d2c <__udivmodsi4>:
     d2c:	a1 e2       	ldi	r26, 0x21	; 33
     d2e:	1a 2e       	mov	r1, r26
     d30:	aa 1b       	sub	r26, r26
     d32:	bb 1b       	sub	r27, r27
     d34:	fd 01       	movw	r30, r26
     d36:	0d c0       	rjmp	.+26     	; 0xd52 <__udivmodsi4_ep>

00000d38 <__udivmodsi4_loop>:
     d38:	aa 1f       	adc	r26, r26
     d3a:	bb 1f       	adc	r27, r27
     d3c:	ee 1f       	adc	r30, r30
     d3e:	ff 1f       	adc	r31, r31
     d40:	a2 17       	cp	r26, r18
     d42:	b3 07       	cpc	r27, r19
     d44:	e4 07       	cpc	r30, r20
     d46:	f5 07       	cpc	r31, r21
     d48:	20 f0       	brcs	.+8      	; 0xd52 <__udivmodsi4_ep>
     d4a:	a2 1b       	sub	r26, r18
     d4c:	b3 0b       	sbc	r27, r19
     d4e:	e4 0b       	sbc	r30, r20
     d50:	f5 0b       	sbc	r31, r21

00000d52 <__udivmodsi4_ep>:
     d52:	66 1f       	adc	r22, r22
     d54:	77 1f       	adc	r23, r23
     d56:	88 1f       	adc	r24, r24
     d58:	99 1f       	adc	r25, r25
     d5a:	1a 94       	dec	r1
     d5c:	69 f7       	brne	.-38     	; 0xd38 <__udivmodsi4_loop>
     d5e:	60 95       	com	r22
     d60:	70 95       	com	r23
     d62:	80 95       	com	r24
     d64:	90 95       	com	r25
     d66:	9b 01       	movw	r18, r22
     d68:	ac 01       	movw	r20, r24
     d6a:	bd 01       	movw	r22, r26
     d6c:	cf 01       	movw	r24, r30
     d6e:	08 95       	ret

00000d70 <__umulhisi3>:
     d70:	a2 9f       	mul	r26, r18
     d72:	b0 01       	movw	r22, r0
     d74:	b3 9f       	mul	r27, r19
     d76:	c0 01       	movw	r24, r0
     d78:	a3 9f       	mul	r26, r19
     d7a:	70 0d       	add	r23, r0
     d7c:	81 1d       	adc	r24, r1
     d7e:	11 24       	eor	r1, r1
     d80:	91 1d       	adc	r25, r1
     d82:	b2 9f       	mul	r27, r18
     d84:	70 0d       	add	r23, r0
     d86:	81 1d       	adc	r24, r1
     d88:	11 24       	eor	r1, r1
     d8a:	91 1d       	adc	r25, r1
     d8c:	08 95       	ret

00000d8e <__mulshisi3>:
     d8e:	b7 ff       	sbrs	r27, 7
     d90:	04 c0       	rjmp	.+8      	; 0xd9a <__muluhisi3>

00000d92 <__mulohisi3>:
     d92:	03 d0       	rcall	.+6      	; 0xd9a <__muluhisi3>
     d94:	82 1b       	sub	r24, r18
     d96:	93 0b       	sbc	r25, r19
     d98:	08 95       	ret

00000d9a <__muluhisi3>:
     d9a:	ea df       	rcall	.-44     	; 0xd70 <__umulhisi3>
     d9c:	a5 9f       	mul	r26, r21
     d9e:	90 0d       	add	r25, r0
     da0:	b4 9f       	mul	r27, r20
     da2:	90 0d       	add	r25, r0
     da4:	a4 9f       	mul	r26, r20
     da6:	80 0d       	add	r24, r0
     da8:	91 1d       	adc	r25, r1
     daa:	11 24       	eor	r1, r1
     dac:	08 95       	ret

00000dae <malloc>:
     dae:	cf 93       	push	r28
     db0:	df 93       	push	r29
     db2:	82 30       	cpi	r24, 0x02	; 2
     db4:	91 05       	cpc	r25, r1
     db6:	10 f4       	brcc	.+4      	; 0xdbc <malloc+0xe>
     db8:	82 e0       	ldi	r24, 0x02	; 2
     dba:	90 e0       	ldi	r25, 0x00	; 0
     dbc:	e0 91 2e 03 	lds	r30, 0x032E	; 0x80032e <__flp>
     dc0:	f0 91 2f 03 	lds	r31, 0x032F	; 0x80032f <__flp+0x1>
     dc4:	20 e0       	ldi	r18, 0x00	; 0
     dc6:	30 e0       	ldi	r19, 0x00	; 0
     dc8:	c0 e0       	ldi	r28, 0x00	; 0
     dca:	d0 e0       	ldi	r29, 0x00	; 0
     dcc:	30 97       	sbiw	r30, 0x00	; 0
     dce:	11 f1       	breq	.+68     	; 0xe14 <malloc+0x66>
     dd0:	40 81       	ld	r20, Z
     dd2:	51 81       	ldd	r21, Z+1	; 0x01
     dd4:	48 17       	cp	r20, r24
     dd6:	59 07       	cpc	r21, r25
     dd8:	c0 f0       	brcs	.+48     	; 0xe0a <malloc+0x5c>
     dda:	48 17       	cp	r20, r24
     ddc:	59 07       	cpc	r21, r25
     dde:	61 f4       	brne	.+24     	; 0xdf8 <malloc+0x4a>
     de0:	82 81       	ldd	r24, Z+2	; 0x02
     de2:	93 81       	ldd	r25, Z+3	; 0x03
     de4:	20 97       	sbiw	r28, 0x00	; 0
     de6:	19 f0       	breq	.+6      	; 0xdee <malloc+0x40>
     de8:	9b 83       	std	Y+3, r25	; 0x03
     dea:	8a 83       	std	Y+2, r24	; 0x02
     dec:	2b c0       	rjmp	.+86     	; 0xe44 <malloc+0x96>
     dee:	90 93 2f 03 	sts	0x032F, r25	; 0x80032f <__flp+0x1>
     df2:	80 93 2e 03 	sts	0x032E, r24	; 0x80032e <__flp>
     df6:	26 c0       	rjmp	.+76     	; 0xe44 <malloc+0x96>
     df8:	21 15       	cp	r18, r1
     dfa:	31 05       	cpc	r19, r1
     dfc:	19 f0       	breq	.+6      	; 0xe04 <malloc+0x56>
     dfe:	42 17       	cp	r20, r18
     e00:	53 07       	cpc	r21, r19
     e02:	18 f4       	brcc	.+6      	; 0xe0a <malloc+0x5c>
     e04:	9a 01       	movw	r18, r20
     e06:	be 01       	movw	r22, r28
     e08:	df 01       	movw	r26, r30
     e0a:	ef 01       	movw	r28, r30
     e0c:	02 80       	ldd	r0, Z+2	; 0x02
     e0e:	f3 81       	ldd	r31, Z+3	; 0x03
     e10:	e0 2d       	mov	r30, r0
     e12:	dc cf       	rjmp	.-72     	; 0xdcc <malloc+0x1e>
     e14:	21 15       	cp	r18, r1
     e16:	31 05       	cpc	r19, r1
     e18:	09 f1       	breq	.+66     	; 0xe5c <malloc+0xae>
     e1a:	28 1b       	sub	r18, r24
     e1c:	39 0b       	sbc	r19, r25
     e1e:	24 30       	cpi	r18, 0x04	; 4
     e20:	31 05       	cpc	r19, r1
     e22:	90 f4       	brcc	.+36     	; 0xe48 <malloc+0x9a>
     e24:	12 96       	adiw	r26, 0x02	; 2
     e26:	8d 91       	ld	r24, X+
     e28:	9c 91       	ld	r25, X
     e2a:	13 97       	sbiw	r26, 0x03	; 3
     e2c:	61 15       	cp	r22, r1
     e2e:	71 05       	cpc	r23, r1
     e30:	21 f0       	breq	.+8      	; 0xe3a <malloc+0x8c>
     e32:	fb 01       	movw	r30, r22
     e34:	93 83       	std	Z+3, r25	; 0x03
     e36:	82 83       	std	Z+2, r24	; 0x02
     e38:	04 c0       	rjmp	.+8      	; 0xe42 <malloc+0x94>
     e3a:	90 93 2f 03 	sts	0x032F, r25	; 0x80032f <__flp+0x1>
     e3e:	80 93 2e 03 	sts	0x032E, r24	; 0x80032e <__flp>
     e42:	fd 01       	movw	r30, r26
     e44:	32 96       	adiw	r30, 0x02	; 2
     e46:	44 c0       	rjmp	.+136    	; 0xed0 <malloc+0x122>
     e48:	fd 01       	movw	r30, r26
     e4a:	e2 0f       	add	r30, r18
     e4c:	f3 1f       	adc	r31, r19
     e4e:	81 93       	st	Z+, r24
     e50:	91 93       	st	Z+, r25
     e52:	22 50       	subi	r18, 0x02	; 2
     e54:	31 09       	sbc	r19, r1
     e56:	2d 93       	st	X+, r18
     e58:	3c 93       	st	X, r19
     e5a:	3a c0       	rjmp	.+116    	; 0xed0 <malloc+0x122>
     e5c:	20 91 2c 03 	lds	r18, 0x032C	; 0x80032c <__brkval>
     e60:	30 91 2d 03 	lds	r19, 0x032D	; 0x80032d <__brkval+0x1>
     e64:	23 2b       	or	r18, r19
     e66:	41 f4       	brne	.+16     	; 0xe78 <malloc+0xca>
     e68:	20 91 02 01 	lds	r18, 0x0102	; 0x800102 <__malloc_heap_start>
     e6c:	30 91 03 01 	lds	r19, 0x0103	; 0x800103 <__malloc_heap_start+0x1>
     e70:	30 93 2d 03 	sts	0x032D, r19	; 0x80032d <__brkval+0x1>
     e74:	20 93 2c 03 	sts	0x032C, r18	; 0x80032c <__brkval>
     e78:	20 91 00 01 	lds	r18, 0x0100	; 0x800100 <__data_start>
     e7c:	30 91 01 01 	lds	r19, 0x0101	; 0x800101 <__data_start+0x1>
     e80:	21 15       	cp	r18, r1
     e82:	31 05       	cpc	r19, r1
     e84:	41 f4       	brne	.+16     	; 0xe96 <malloc+0xe8>
     e86:	2d b7       	in	r18, 0x3d	; 61
     e88:	3e b7       	in	r19, 0x3e	; 62
     e8a:	40 91 04 01 	lds	r20, 0x0104	; 0x800104 <__malloc_margin>
     e8e:	50 91 05 01 	lds	r21, 0x0105	; 0x800105 <__malloc_margin+0x1>
     e92:	24 1b       	sub	r18, r20
     e94:	35 0b       	sbc	r19, r21
     e96:	e0 91 2c 03 	lds	r30, 0x032C	; 0x80032c <__brkval>
     e9a:	f0 91 2d 03 	lds	r31, 0x032D	; 0x80032d <__brkval+0x1>
     e9e:	e2 17       	cp	r30, r18
     ea0:	f3 07       	cpc	r31, r19
     ea2:	a0 f4       	brcc	.+40     	; 0xecc <malloc+0x11e>
     ea4:	2e 1b       	sub	r18, r30
     ea6:	3f 0b       	sbc	r19, r31
     ea8:	28 17       	cp	r18, r24
     eaa:	39 07       	cpc	r19, r25
     eac:	78 f0       	brcs	.+30     	; 0xecc <malloc+0x11e>
     eae:	ac 01       	movw	r20, r24
     eb0:	4e 5f       	subi	r20, 0xFE	; 254
     eb2:	5f 4f       	sbci	r21, 0xFF	; 255
     eb4:	24 17       	cp	r18, r20
     eb6:	35 07       	cpc	r19, r21
     eb8:	48 f0       	brcs	.+18     	; 0xecc <malloc+0x11e>
     eba:	4e 0f       	add	r20, r30
     ebc:	5f 1f       	adc	r21, r31
     ebe:	50 93 2d 03 	sts	0x032D, r21	; 0x80032d <__brkval+0x1>
     ec2:	40 93 2c 03 	sts	0x032C, r20	; 0x80032c <__brkval>
     ec6:	81 93       	st	Z+, r24
     ec8:	91 93       	st	Z+, r25
     eca:	02 c0       	rjmp	.+4      	; 0xed0 <malloc+0x122>
     ecc:	e0 e0       	ldi	r30, 0x00	; 0
     ece:	f0 e0       	ldi	r31, 0x00	; 0
     ed0:	cf 01       	movw	r24, r30
     ed2:	df 91       	pop	r29
     ed4:	cf 91       	pop	r28
     ed6:	08 95       	ret

00000ed8 <free>:
     ed8:	0f 93       	push	r16
     eda:	1f 93       	push	r17
     edc:	cf 93       	push	r28
     ede:	df 93       	push	r29
     ee0:	00 97       	sbiw	r24, 0x00	; 0
     ee2:	09 f4       	brne	.+2      	; 0xee6 <free+0xe>
     ee4:	8c c0       	rjmp	.+280    	; 0xffe <free+0x126>
     ee6:	fc 01       	movw	r30, r24
     ee8:	32 97       	sbiw	r30, 0x02	; 2
     eea:	13 82       	std	Z+3, r1	; 0x03
     eec:	12 82       	std	Z+2, r1	; 0x02
     eee:	00 91 2e 03 	lds	r16, 0x032E	; 0x80032e <__flp>
     ef2:	10 91 2f 03 	lds	r17, 0x032F	; 0x80032f <__flp+0x1>
     ef6:	01 15       	cp	r16, r1
     ef8:	11 05       	cpc	r17, r1
     efa:	81 f4       	brne	.+32     	; 0xf1c <free+0x44>
     efc:	20 81       	ld	r18, Z
     efe:	31 81       	ldd	r19, Z+1	; 0x01
     f00:	82 0f       	add	r24, r18
     f02:	93 1f       	adc	r25, r19
     f04:	20 91 2c 03 	lds	r18, 0x032C	; 0x80032c <__brkval>
     f08:	30 91 2d 03 	lds	r19, 0x032D	; 0x80032d <__brkval+0x1>
     f0c:	28 17       	cp	r18, r24
     f0e:	39 07       	cpc	r19, r25
     f10:	79 f5       	brne	.+94     	; 0xf70 <free+0x98>
     f12:	f0 93 2d 03 	sts	0x032D, r31	; 0x80032d <__brkval+0x1>
     f16:	e0 93 2c 03 	sts	0x032C, r30	; 0x80032c <__brkval>
     f1a:	71 c0       	rjmp	.+226    	; 0xffe <free+0x126>
     f1c:	d8 01       	movw	r26, r16
     f1e:	40 e0       	ldi	r20, 0x00	; 0
     f20:	50 e0       	ldi	r21, 0x00	; 0
     f22:	ae 17       	cp	r26, r30
     f24:	bf 07       	cpc	r27, r31
     f26:	50 f4       	brcc	.+20     	; 0xf3c <free+0x64>
     f28:	12 96       	adiw	r26, 0x02	; 2
     f2a:	2d 91       	ld	r18, X+
     f2c:	3c 91       	ld	r19, X
     f2e:	13 97       	sbiw	r26, 0x03	; 3
     f30:	ad 01       	movw	r20, r26
     f32:	21 15       	cp	r18, r1
     f34:	31 05       	cpc	r19, r1
     f36:	09 f1       	breq	.+66     	; 0xf7a <free+0xa2>
     f38:	d9 01       	movw	r26, r18
     f3a:	f3 cf       	rjmp	.-26     	; 0xf22 <free+0x4a>
     f3c:	9d 01       	movw	r18, r26
     f3e:	da 01       	movw	r26, r20
     f40:	33 83       	std	Z+3, r19	; 0x03
     f42:	22 83       	std	Z+2, r18	; 0x02
     f44:	60 81       	ld	r22, Z
     f46:	71 81       	ldd	r23, Z+1	; 0x01
     f48:	86 0f       	add	r24, r22
     f4a:	97 1f       	adc	r25, r23
     f4c:	82 17       	cp	r24, r18
     f4e:	93 07       	cpc	r25, r19
     f50:	69 f4       	brne	.+26     	; 0xf6c <free+0x94>
     f52:	ec 01       	movw	r28, r24
     f54:	28 81       	ld	r18, Y
     f56:	39 81       	ldd	r19, Y+1	; 0x01
     f58:	26 0f       	add	r18, r22
     f5a:	37 1f       	adc	r19, r23
     f5c:	2e 5f       	subi	r18, 0xFE	; 254
     f5e:	3f 4f       	sbci	r19, 0xFF	; 255
     f60:	31 83       	std	Z+1, r19	; 0x01
     f62:	20 83       	st	Z, r18
     f64:	8a 81       	ldd	r24, Y+2	; 0x02
     f66:	9b 81       	ldd	r25, Y+3	; 0x03
     f68:	93 83       	std	Z+3, r25	; 0x03
     f6a:	82 83       	std	Z+2, r24	; 0x02
     f6c:	45 2b       	or	r20, r21
     f6e:	29 f4       	brne	.+10     	; 0xf7a <free+0xa2>
     f70:	f0 93 2f 03 	sts	0x032F, r31	; 0x80032f <__flp+0x1>
     f74:	e0 93 2e 03 	sts	0x032E, r30	; 0x80032e <__flp>
     f78:	42 c0       	rjmp	.+132    	; 0xffe <free+0x126>
     f7a:	13 96       	adiw	r26, 0x03	; 3
     f7c:	fc 93       	st	X, r31
     f7e:	ee 93       	st	-X, r30
     f80:	12 97       	sbiw	r26, 0x02	; 2
     f82:	ed 01       	movw	r28, r26
     f84:	49 91       	ld	r20, Y+
     f86:	59 91       	ld	r21, Y+
     f88:	9e 01       	movw	r18, r28
     f8a:	24 0f       	add	r18, r20
     f8c:	35 1f       	adc	r19, r21
     f8e:	e2 17       	cp	r30, r18
     f90:	f3 07       	cpc	r31, r19
     f92:	71 f4       	brne	.+28     	; 0xfb0 <free+0xd8>
     f94:	80 81       	ld	r24, Z
     f96:	91 81       	ldd	r25, Z+1	; 0x01
     f98:	84 0f       	add	r24, r20
     f9a:	95 1f       	adc	r25, r21
     f9c:	02 96       	adiw	r24, 0x02	; 2
     f9e:	11 96       	adiw	r26, 0x01	; 1
     fa0:	9c 93       	st	X, r25
     fa2:	8e 93       	st	-X, r24
     fa4:	82 81       	ldd	r24, Z+2	; 0x02
     fa6:	93 81       	ldd	r25, Z+3	; 0x03
     fa8:	13 96       	adiw	r26, 0x03	; 3
     faa:	9c 93       	st	X, r25
     fac:	8e 93       	st	-X, r24
     fae:	12 97       	sbiw	r26, 0x02	; 2
     fb0:	e0 e0       	ldi	r30, 0x00	; 0
     fb2:	f0 e0       	ldi	r31, 0x00	; 0
     fb4:	d8 01       	movw	r26, r16
     fb6:	12 96       	adiw	r26, 0x02	; 2
     fb8:	8d 91       	ld	r24, X+
     fba:	9c 91       	ld	r25, X
     fbc:	13 97       	sbiw	r26, 0x03	; 3
     fbe:	00 97       	sbiw	r24, 0x00	; 0
     fc0:	19 f0       	breq	.+6      	; 0xfc8 <free+0xf0>
     fc2:	f8 01       	movw	r30, r16
     fc4:	8c 01       	movw	r16, r24
     fc6:	f6 cf       	rjmp	.-20     	; 0xfb4 <free+0xdc>
     fc8:	8d 91       	ld	r24, X+
     fca:	9c 91       	ld	r25, X
     fcc:	98 01       	movw	r18, r16
     fce:	2e 5f       	subi	r18, 0xFE	; 254
     fd0:	3f 4f       	sbci	r19, 0xFF	; 255
     fd2:	82 0f       	add	r24, r18
     fd4:	93 1f       	adc	r25, r19
     fd6:	20 91 2c 03 	lds	r18, 0x032C	; 0x80032c <__brkval>
     fda:	30 91 2d 03 	lds	r19, 0x032D	; 0x80032d <__brkval+0x1>
     fde:	28 17       	cp	r18, r24
     fe0:	39 07       	cpc	r19, r25
     fe2:	69 f4       	brne	.+26     	; 0xffe <free+0x126>
     fe4:	30 97       	sbiw	r30, 0x00	; 0
     fe6:	29 f4       	brne	.+10     	; 0xff2 <free+0x11a>
     fe8:	10 92 2f 03 	sts	0x032F, r1	; 0x80032f <__flp+0x1>
     fec:	10 92 2e 03 	sts	0x032E, r1	; 0x80032e <__flp>
     ff0:	02 c0       	rjmp	.+4      	; 0xff6 <free+0x11e>
     ff2:	13 82       	std	Z+3, r1	; 0x03
     ff4:	12 82       	std	Z+2, r1	; 0x02
     ff6:	10 93 2d 03 	sts	0x032D, r17	; 0x80032d <__brkval+0x1>
     ffa:	00 93 2c 03 	sts	0x032C, r16	; 0x80032c <__brkval>
     ffe:	df 91       	pop	r29
    1000:	cf 91       	pop	r28
    1002:	1f 91       	pop	r17
    1004:	0f 91       	pop	r16
    1006:	08 95       	ret

00001008 <strtok>:
    1008:	4a e2       	ldi	r20, 0x2A	; 42
    100a:	51 e0       	ldi	r21, 0x01	; 1
    100c:	1e c0       	rjmp	.+60     	; 0x104a <strtok_r>

0000100e <memcpy>:
    100e:	fb 01       	movw	r30, r22
    1010:	dc 01       	movw	r26, r24
    1012:	02 c0       	rjmp	.+4      	; 0x1018 <memcpy+0xa>
    1014:	01 90       	ld	r0, Z+
    1016:	0d 92       	st	X+, r0
    1018:	41 50       	subi	r20, 0x01	; 1
    101a:	50 40       	sbci	r21, 0x00	; 0
    101c:	d8 f7       	brcc	.-10     	; 0x1014 <memcpy+0x6>
    101e:	08 95       	ret

00001020 <memset>:
    1020:	dc 01       	movw	r26, r24
    1022:	01 c0       	rjmp	.+2      	; 0x1026 <memset+0x6>
    1024:	6d 93       	st	X+, r22
    1026:	41 50       	subi	r20, 0x01	; 1
    1028:	50 40       	sbci	r21, 0x00	; 0
    102a:	e0 f7       	brcc	.-8      	; 0x1024 <memset+0x4>
    102c:	08 95       	ret

0000102e <strncmp>:
    102e:	fb 01       	movw	r30, r22
    1030:	dc 01       	movw	r26, r24
    1032:	41 50       	subi	r20, 0x01	; 1
    1034:	50 40       	sbci	r21, 0x00	; 0
    1036:	30 f0       	brcs	.+12     	; 0x1044 <strncmp+0x16>
    1038:	8d 91       	ld	r24, X+
    103a:	01 90       	ld	r0, Z+
    103c:	80 19       	sub	r24, r0
    103e:	19 f4       	brne	.+6      	; 0x1046 <strncmp+0x18>
    1040:	00 20       	and	r0, r0
    1042:	b9 f7       	brne	.-18     	; 0x1032 <strncmp+0x4>
    1044:	88 1b       	sub	r24, r24
    1046:	99 0b       	sbc	r25, r25
    1048:	08 95       	ret

0000104a <strtok_r>:
    104a:	fa 01       	movw	r30, r20
    104c:	a1 91       	ld	r26, Z+
    104e:	b0 81       	ld	r27, Z
    1050:	00 97       	sbiw	r24, 0x00	; 0
    1052:	19 f4       	brne	.+6      	; 0x105a <strtok_r+0x10>
    1054:	10 97       	sbiw	r26, 0x00	; 0
    1056:	e1 f0       	breq	.+56     	; 0x1090 <strtok_r+0x46>
    1058:	cd 01       	movw	r24, r26
    105a:	dc 01       	movw	r26, r24
    105c:	cd 01       	movw	r24, r26
    105e:	0d 90       	ld	r0, X+
    1060:	00 20       	and	r0, r0
    1062:	11 f4       	brne	.+4      	; 0x1068 <strtok_r+0x1e>
    1064:	c0 01       	movw	r24, r0
    1066:	13 c0       	rjmp	.+38     	; 0x108e <strtok_r+0x44>
    1068:	fb 01       	movw	r30, r22
    106a:	21 91       	ld	r18, Z+
    106c:	22 23       	and	r18, r18
    106e:	19 f0       	breq	.+6      	; 0x1076 <strtok_r+0x2c>
    1070:	20 15       	cp	r18, r0
    1072:	d9 f7       	brne	.-10     	; 0x106a <strtok_r+0x20>
    1074:	f3 cf       	rjmp	.-26     	; 0x105c <strtok_r+0x12>
    1076:	fb 01       	movw	r30, r22
    1078:	21 91       	ld	r18, Z+
    107a:	20 15       	cp	r18, r0
    107c:	19 f4       	brne	.+6      	; 0x1084 <strtok_r+0x3a>
    107e:	1e 92       	st	-X, r1
    1080:	11 96       	adiw	r26, 0x01	; 1
    1082:	06 c0       	rjmp	.+12     	; 0x1090 <strtok_r+0x46>
    1084:	22 23       	and	r18, r18
    1086:	c1 f7       	brne	.-16     	; 0x1078 <strtok_r+0x2e>
    1088:	0d 90       	ld	r0, X+
    108a:	00 20       	and	r0, r0
    108c:	a1 f7       	brne	.-24     	; 0x1076 <strtok_r+0x2c>
    108e:	d0 01       	movw	r26, r0
    1090:	fa 01       	movw	r30, r20
    1092:	a1 93       	st	Z+, r26
    1094:	b0 83       	st	Z, r27
    1096:	08 95       	ret

00001098 <_exit>:
    1098:	f8 94       	cli

0000109a <__stop_program>:
    109a:	ff cf       	rjmp	.-2      	; 0x109a <__stop_program>
